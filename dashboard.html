<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>프로미카 로그 분석 대시보드</title>
  <script src="js/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #e0e0e0;
      padding: 20px;
      min-height: 100vh;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px;
      background: rgba(0, 255, 255, 0.05);
      border-radius: 15px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
    }

    .header h1 {
      font-size: 36px;
      color: #00ffff;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      margin-bottom: 10px;
    }

    .header p {
      font-size: 16px;
      color: #00d9ff;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      background: rgba(0, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.2);
    }

    .controls label {
      color: #00ffff;
      font-weight: bold;
      margin-right: 10px;
    }

    .controls input, .controls select {
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      color: #00ffff;
      border-radius: 5px;
      font-size: 14px;
    }

    .controls button {
      padding: 10px 25px;
      background: linear-gradient(135deg, #00d9ff, #00ffff);
      color: #0a0e27;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(0, 255, 255, 0.05);
      padding: 25px;
      border-radius: 10px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      text-align: center;
      transition: all 0.3s;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 30px rgba(0, 255, 255, 0.3);
    }

    .stat-card .label {
      font-size: 14px;
      color: #00d9ff;
      margin-bottom: 10px;
    }

    .stat-card .value {
      font-size: 32px;
      color: #00ffff;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .chart-container {
      background: rgba(0, 255, 255, 0.05);
      padding: 25px;
      border-radius: 10px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      margin-bottom: 30px;
      position: relative;
    }

    .chart-container h3 {
      color: #00ffff;
      margin-bottom: 20px;
      font-size: 20px;
      text-align: center;
    }

    .chart-wrapper {
      position: relative;
      height: 250px;
    }
    
    .jarvis-analysis {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.1), rgba(0, 217, 255, 0.05));
      border: 2px solid rgba(0, 255, 255, 0.5);
      border-radius: 15px;
      padding: 30px;
      margin-bottom: 30px;
      box-shadow: 0 0 40px rgba(0, 255, 255, 0.3);
      position: relative;
      overflow: hidden;
    }
    
    .jarvis-analysis::before {
      content: '🤖 JARVIS AI ANALYSIS';
      display: block;
      font-size: 14px;
      color: #00ffff;
      font-weight: bold;
      margin-bottom: 15px;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    .jarvis-content {
      font-size: 16px;
      line-height: 1.8;
      color: #e0e0e0;
    }
    
    .jarvis-content h4 {
      color: #00ffff;
      font-size: 18px;
      margin: 20px 0 10px 0;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }
    
    .jarvis-content ul {
      list-style: none;
      padding-left: 0;
    }
    
    .jarvis-content li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
    }
    
    .jarvis-content li::before {
      content: '▸';
      position: absolute;
      left: 0;
      color: #00ffff;
      font-size: 18px;
    }
    
    .jarvis-content .highlight {
      color: #00ffff;
      font-weight: bold;
    }
    
    .jarvis-content .warning {
      color: #ffaa00;
      font-weight: bold;
    }
    
    .jarvis-content .critical {
      color: #ff6b6b;
      font-weight: bold;
    }

    .loading {
      text-align: center;
      padding: 50px;
      color: #00d9ff;
      font-size: 18px;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    .error {
      background: rgba(255, 0, 0, 0.1);
      border: 2px solid rgba(255, 0, 0, 0.5);
      padding: 20px;
      border-radius: 10px;
      color: #ff6b6b;
      text-align: center;
      margin: 20px 0;
    }

    .date-range-info {
      text-align: center;
      padding: 15px;
      background: rgba(0, 255, 255, 0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      color: #00ffff;
      font-size: 16px;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 30px;
      margin-bottom: 30px;
    }

    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
      
      .controls {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>📊 프로미카 로그 분석 대시보드</h1>
    <p>월간 로그 데이터 추이 및 통계 시각화</p>
  </div>

  <div class="controls">
    <div>
      <label>OpenSearch 인덱스:</label>
      <input type="text" id="indexName" value="contest_pm_task" placeholder="인덱스 이름">
    </div>
    <div>
      <label>시작 날짜:</label>
      <input type="date" id="startDate">
    </div>
    <div>
      <label>종료 날짜:</label>
      <input type="date" id="endDate">
    </div>
    <button onclick="loadDashboardData()">🔄 데이터 불러오기</button>
    <button onclick="refreshDashboard()">🔃 새로고침</button>
  </div>

  <div id="dateRangeInfo" class="date-range-info" style="display: none;"></div>

  <div id="loadingIndicator" class="loading" style="display: none;">데이터 로딩 중</div>
  <div id="errorMessage" class="error" style="display: none;"></div>

  <!-- JARVIS AI 분석 소견 -->
  <div id="jarvisAnalysis" class="jarvis-analysis" style="display: none;">
    <div class="jarvis-content" id="jarvisContent">
      <!-- AI 분석 내용이 여기에 표시됩니다 -->
    </div>
  </div>

  <div class="stats-grid">
    <div class="stat-card">
      <div class="label">총 분석 일수</div>
      <div class="value" id="totalDays">-</div>
    </div>
    <div class="stat-card">
      <div class="label">총 요청 수</div>
      <div class="value" id="totalRequests">-</div>
    </div>
    <div class="stat-card">
      <div class="label">총 에러 수</div>
      <div class="value" id="totalErrors">-</div>
    </div>
    <div class="stat-card">
      <div class="label">일평균 요청</div>
      <div class="value" id="avgRequests">-</div>
    </div>
  </div>

  <div class="chart-container">
    <h3>📈 일별 요청 수 추이</h3>
    <div class="chart-wrapper">
      <canvas id="dailyRequestsChart"></canvas>
    </div>
  </div>

  <div class="chart-container">
    <h3>⚠️ 일별 에러 발생 추이</h3>
    <div class="chart-wrapper">
      <canvas id="dailyErrorsChart"></canvas>
    </div>
  </div>

  <div class="grid-2">
    <div class="chart-container">
      <h3>⏰ 시간대별 평균 사용량</h3>
      <div class="chart-wrapper">
        <canvas id="hourlyUsageChart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <h3>📱 인기 기기 TOP 10</h3>
      <div class="chart-wrapper">
        <canvas id="topDevicesChart"></canvas>
      </div>
    </div>
  </div>

  <div class="grid-2">
    <div class="chart-container">
      <h3>👥 활발한 사용자 TOP 10</h3>
      <div class="chart-wrapper">
        <canvas id="topUsersChart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <h3>🌍 지역별 사용 분포</h3>
      <div class="chart-wrapper">
        <canvas id="locationsChart"></canvas>
      </div>
    </div>
  </div>

  <script>
    const OPENSEARCH_API_BASE = "http://10.10.22.81:8080";
    let charts = {};

    // 페이지 로드 시 오늘 날짜를 종료일로, 30일 전을 시작일로 설정
    window.addEventListener('DOMContentLoaded', () => {
      const today = new Date();
      const thirtyDaysAgo = new Date(today);
      thirtyDaysAgo.setDate(today.getDate() - 30);

      document.getElementById('startDate').value = formatDate(thirtyDaysAgo);
      document.getElementById('endDate').value = formatDate(today);
    });

    function formatDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function showLoading(show) {
      document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMessage');
      if (message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
      } else {
        errorDiv.style.display = 'none';
      }
    }

    async function loadDashboardData() {
      showLoading(true);
      showError(null);

      const indexName = document.getElementById('indexName').value;
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;

      if (!startDate || !endDate) {
        showError('시작 날짜와 종료 날짜를 선택하세요.');
        showLoading(false);
        return;
      }

      try {
        console.log('[Dashboard] 데이터 로딩 시작:', { indexName, startDate, endDate });

        // 날짜 범위 내의 모든 날짜에 대해 검색
        const allDocuments = [];
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        const dateRangeInfo = document.getElementById('dateRangeInfo');
        dateRangeInfo.textContent = `📅 데이터 수집 중... (${startDate} ~ ${endDate})`;
        dateRangeInfo.style.display = 'block';

        // 날짜 범위 내의 각 날짜별로 검색
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
          const dateStr = formatDate(d);
          console.log('[Dashboard] 날짜별 검색:', dateStr);

          try {
            // keyword_search로 날짜 검색
            const response = await fetch(`${OPENSEARCH_API_BASE}/keyword_search`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: dateStr,
                index: indexName,
                k: 10
              })
            });

            if (response.ok) {
              const data = await response.json();
              if (data.result && data.result.length > 0) {
                // 결과가 문자열 배열인지 객체 배열인지 확인
                const docs = data.result.map(item => {
                  if (typeof item === 'string') {
                    try {
                      return JSON.parse(item);
                    } catch {
                      return null;
                    }
                  }
                  return item;
                }).filter(doc => doc !== null);

                // 해당 날짜의 문서만 필터링
                const dateDocs = docs.filter(doc => {
                  const logDate = doc.local_statistics?.logDate || doc.log_date || '';
                  return logDate === dateStr;
                });

                if (dateDocs.length > 0) {
                  allDocuments.push(dateDocs[0]); // 날짜당 하나의 문서만
                  console.log('[Dashboard] 발견:', dateStr, dateDocs[0]);
                }
              }
            }
          } catch (err) {
            console.warn('[Dashboard] 날짜 검색 실패:', dateStr, err);
          }

          // UI 업데이트
          dateRangeInfo.textContent = `📅 데이터 수집 중... ${allDocuments.length}일치 발견`;
        }

        console.log('[Dashboard] 총 데이터 수집 완료:', allDocuments.length, '일');

        if (allDocuments.length === 0) {
          showError(`${startDate}부터 ${endDate}까지 데이터가 없습니다.\n먼저 btn_learn_6으로 로그를 학습시켜주세요.\n\n💡 팁: 파일명을 "YYYYMMDD.log" 형식으로 업로드하세요 (예: 20251030.log)`);
          showLoading(false);
          return;
        }

        // 데이터 처리 및 시각화
        processAndVisualize(allDocuments, startDate, endDate);
        showLoading(false);

      } catch (error) {
        console.error('[Dashboard] 데이터 로딩 실패:', error);
        showError(`데이터 로딩 실패: ${error.message}\n\nOpenSearch 서버가 실행 중인지 확인하세요.`);
        showLoading(false);
      }
    }

    function processAndVisualize(documents, startDate, endDate) {
      console.log('[Dashboard] 데이터 처리 시작:', documents.length, '개 문서');

      // 날짜별로 정렬
      documents.sort((a, b) => {
        const dateA = a.local_statistics?.logDate || a.log_date || '';
        const dateB = b.local_statistics?.logDate || b.log_date || '';
        return dateA.localeCompare(dateB);
      });

      // 통계 계산
      const dailyData = [];
      let totalRequests = 0;
      let totalErrors = 0;
      const hourlyUsage = {};
      const devices = {};
      const users = {};
      const locations = {};

      documents.forEach(doc => {
        const stats = doc.local_statistics || doc.ai_analysis || doc;
        const logDate = stats.logDate || doc.log_date || '날짜 미상';
        const logDateFormatted = stats.logDateFormatted || doc.log_date_formatted || logDate;

        // 일별 데이터
        const requests = parseInt(stats.totalRequests || 0);
        const errors = parseInt(stats.totalErrors || (stats.errorSamples || stats.errors || []).length);

        dailyData.push({
          date: logDate,
          dateFormatted: logDateFormatted,
          requests: requests,
          errors: errors
        });

        totalRequests += requests;
        totalErrors += errors;

        // 시간대별 사용량 집계
        const hourly = stats.hourlyUsage || {};
        Object.entries(hourly).forEach(([hour, count]) => {
          hourlyUsage[hour] = (hourlyUsage[hour] || 0) + count;
        });

        // 기기 집계
        const topDevices = stats.topDevices || {};
        Object.entries(topDevices).forEach(([device, count]) => {
          devices[device] = (devices[device] || 0) + count;
        });

        // 사용자 집계
        const topUsers = stats.topUsers || {};
        Object.entries(topUsers).forEach(([user, count]) => {
          users[user] = (users[user] || 0) + count;
        });

        // 지역 집계
        const topLocations = stats.topLocations || {};
        Object.entries(topLocations).forEach(([loc, count]) => {
          locations[loc] = (locations[loc] || 0) + count;
        });
      });

      // 통계 카드 업데이트
      document.getElementById('totalDays').textContent = documents.length.toLocaleString();
      document.getElementById('totalRequests').textContent = totalRequests.toLocaleString();
      document.getElementById('totalErrors').textContent = totalErrors.toLocaleString();
      document.getElementById('avgRequests').textContent = Math.round(totalRequests / documents.length).toLocaleString();

      // 날짜 범위 정보 표시
      const dateRangeInfo = document.getElementById('dateRangeInfo');
      dateRangeInfo.textContent = `📅 분석 기간: ${startDate} ~ ${endDate} (${documents.length}일)`;
      dateRangeInfo.style.display = 'block';

      // 차트 생성
      createDailyRequestsChart(dailyData);
      createDailyErrorsChart(dailyData);
      createHourlyUsageChart(hourlyUsage);
      createTopDevicesChart(devices);
      createTopUsersChart(users);
      createLocationsChart(locations);

      // AI 분석 소견 생성
      generateJarvisAnalysis({
        dailyData,
        totalRequests,
        totalErrors,
        hourlyUsage,
        devices,
        users,
        locations,
        documents
      });

      console.log('[Dashboard] 시각화 완료');
    }

    function generateJarvisAnalysis(data) {
      const { dailyData, totalRequests, totalErrors, hourlyUsage, devices, users, locations, documents } = data;
      
      // 추세 분석
      const avgRequests = Math.round(totalRequests / documents.length);
      const avgErrors = Math.round(totalErrors / documents.length);
      const errorRate = ((totalErrors / totalRequests) * 100).toFixed(3);
      
      // 요청 수 추이
      const requestTrend = dailyData.length >= 3 ? 
        (dailyData[dailyData.length - 1].requests > dailyData[0].requests ? '증가' : '감소') : '분석 불가';
      
      // 에러 추이
      const recentErrors = dailyData.slice(-7).reduce((sum, d) => sum + d.errors, 0);
      const previousErrors = dailyData.slice(0, Math.min(7, dailyData.length)).reduce((sum, d) => sum + d.errors, 0);
      const errorTrend = recentErrors > previousErrors ? '증가' : '감소';
      
      // 피크 시간대
      const peakHours = Object.entries(hourlyUsage)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(h => `${h[0]}시`);
      
      // 가장 많이 사용된 기기
      const topDevice = Object.entries(devices).sort((a, b) => b[1] - a[1])[0];
      
      // 에러가 가장 많았던 날
      const maxErrorDay = dailyData.reduce((max, d) => d.errors > max.errors ? d : max, dailyData[0]);
      
      // 요청이 가장 많았던 날
      const maxRequestDay = dailyData.reduce((max, d) => d.requests > max.requests ? d : max, dailyData[0]);
      
      // 주의사항 생성
      const warnings = [];
      if (errorRate > 0.1) warnings.push(`에러율이 <span class="critical">${errorRate}%</span>로 높습니다`);
      if (errorTrend === '증가') warnings.push(`최근 7일간 에러 발생이 <span class="warning">증가</span> 추세입니다`);
      if (recentErrors > avgErrors * 1.5) warnings.push(`최근 에러 발생이 평균 대비 <span class="warning">50% 이상 증가</span>했습니다`);
      
      // 권장사항 생성
      const recommendations = [];
      if (peakHours.length > 0) recommendations.push(`피크 시간대(${peakHours.join(', ')}) 서버 리소스 모니터링 강화`);
      if (maxErrorDay) recommendations.push(`${maxErrorDay.dateFormatted} 에러 로그 상세 분석 필요`);
      if (topDevice) recommendations.push(`${topDevice[0]} 기기 호환성 및 성능 최적화`);
      
      // HTML 생성
      const jarvisHTML = `
        <h4>📊 전반적인 상황</h4>
        <ul>
          <li>분석 기간: <span class="highlight">${documents.length}일</span> (${dailyData[0].dateFormatted} ~ ${dailyData[dailyData.length-1].dateFormatted})</li>
          <li>총 요청 수: <span class="highlight">${totalRequests.toLocaleString()}건</span> (일평균 ${avgRequests.toLocaleString()}건)</li>
          <li>총 에러 수: <span class="highlight">${totalErrors.toLocaleString()}건</span> (일평균 ${avgErrors.toLocaleString()}건)</li>
          <li>에러율: <span class="${errorRate > 0.1 ? 'warning' : 'highlight'}">${errorRate}%</span></li>
          <li>요청 추이: 기간 대비 <span class="highlight">${requestTrend}</span></li>
        </ul>
        
        <h4>🔍 패턴 분석</h4>
        <ul>
          <li>피크 시간대: <span class="highlight">${peakHours.join(', ')}</span></li>
          <li>최고 사용일: <span class="highlight">${maxRequestDay.dateFormatted}</span> (${maxRequestDay.requests.toLocaleString()}건)</li>
          <li>최다 에러일: <span class="highlight">${maxErrorDay.dateFormatted}</span> (${maxErrorDay.errors.toLocaleString()}건)</li>
          <li>주요 기기: <span class="highlight">${topDevice ? topDevice[0] : '데이터 없음'}</span></li>
        </ul>
        
        ${warnings.length > 0 ? `
        <h4>⚠️ 주의사항</h4>
        <ul>
          ${warnings.map(w => `<li>${w}</li>`).join('')}
        </ul>
        ` : ''}
        
        <h4>💡 권장사항</h4>
        <ul>
          ${recommendations.map(r => `<li>${r}</li>`).join('')}
          <li>일별 에러 추이를 모니터링하여 이상 징후 조기 발견</li>
          <li>시간대별 사용 패턴을 고려한 리소스 스케일링 전략 수립</li>
        </ul>
        
        <h4>🔮 예측 및 대응</h4>
        <ul>
          <li>현재 추세가 유지될 경우 ${requestTrend === '증가' ? '서버 부하 증가 예상' : '안정적인 운영 가능'}</li>
          <li>에러 ${errorTrend} 추세 - ${errorTrend === '증가' ? '<span class="warning">즉시 원인 분석 필요</span>' : '<span class="highlight">정상 범위 유지</span>'}</li>
          <li>다음 피크 시간대(${peakHours[0]}) 전 시스템 상태 점검 권장</li>
        </ul>
      `;
      
      document.getElementById('jarvisContent').innerHTML = jarvisHTML;
      document.getElementById('jarvisAnalysis').style.display = 'block';
    }

    function createDailyRequestsChart(dailyData) {
      const ctx = document.getElementById('dailyRequestsChart');
      if (charts.dailyRequests) charts.dailyRequests.destroy();

      charts.dailyRequests = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dailyData.map(d => d.dateFormatted),
          datasets: [{
            label: '일별 요청 수',
            data: dailyData.map(d => d.requests),
            borderColor: '#00ffff',
            backgroundColor: 'rgba(0, 255, 255, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createDailyErrorsChart(dailyData) {
      const ctx = document.getElementById('dailyErrorsChart');
      if (charts.dailyErrors) charts.dailyErrors.destroy();

      charts.dailyErrors = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: dailyData.map(d => d.dateFormatted),
          datasets: [{
            label: '일별 에러 수',
            data: dailyData.map(d => d.errors),
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: '#ff6b6b',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createHourlyUsageChart(hourlyUsage) {
      const ctx = document.getElementById('hourlyUsageChart');
      if (charts.hourlyUsage) charts.hourlyUsage.destroy();

      const hours = Array.from({ length: 24 }, (_, i) => String(i).padStart(2, '0'));
      const data = hours.map(h => hourlyUsage[h] || 0);

      charts.hourlyUsage = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: hours.map(h => `${h}시`),
          datasets: [{
            label: '시간대별 사용량',
            data: data,
            borderColor: '#00ffff',
            backgroundColor: 'rgba(0, 255, 255, 0.2)',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            r: { 
              ticks: { color: '#00d9ff' }, 
              grid: { color: 'rgba(0, 255, 255, 0.1)' },
              pointLabels: { color: '#00d9ff' }
            }
          }
        }
      });
    }

    function createTopDevicesChart(devices) {
      const ctx = document.getElementById('topDevicesChart');
      if (charts.topDevices) charts.topDevices.destroy();

      const sorted = Object.entries(devices).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.topDevices = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: sorted.map(d => d[0]),
          datasets: [{
            data: sorted.map(d => d[1]),
            backgroundColor: [
              '#00ffff', '#00d9ff', '#00b3cc', '#008c99', '#006666',
              '#ffaa00', '#ff8800', '#ff6600', '#ff4400', '#ff2200'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' }, position: 'right' }
          }
        }
      });
    }

    function createTopUsersChart(users) {
      const ctx = document.getElementById('topUsersChart');
      if (charts.topUsers) charts.topUsers.destroy();

      const sorted = Object.entries(users).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.topUsers = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sorted.map(u => u[0]),
          datasets: [{
            label: '사용량',
            data: sorted.map(u => u[1]),
            backgroundColor: 'rgba(0, 255, 255, 0.6)',
            borderColor: '#00ffff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createLocationsChart(locations) {
      const ctx = document.getElementById('locationsChart');
      if (charts.locations) charts.locations.destroy();

      const sorted = Object.entries(locations).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.locations = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: sorted.map(l => `지역 ${l[0]}`),
          datasets: [{
            data: sorted.map(l => l[1]),
            backgroundColor: [
              '#00ffff', '#00d9ff', '#00b3cc', '#008c99', '#006666',
              '#ffaa00', '#ff8800', '#ff6600', '#ff4400', '#ff2200'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' }, position: 'right' }
          }
        }
      });
    }

    function refreshDashboard() {
      loadDashboardData();
    }
  </script>
</body>
</html>
