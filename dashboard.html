<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>프로미카 로그 분석 대시보드</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #e0e0e0;
      padding: 20px;
      min-height: 100vh;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px;
      background: rgba(0, 255, 255, 0.05);
      border-radius: 15px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
    }

    .header h1 {
      font-size: 36px;
      color: #00ffff;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      margin-bottom: 10px;
    }

    .header p {
      font-size: 16px;
      color: #00d9ff;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      background: rgba(0, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 255, 0.2);
    }

    .controls label {
      color: #00ffff;
      font-weight: bold;
      margin-right: 10px;
    }

    .controls input, .controls select {
      padding: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      color: #00ffff;
      border-radius: 5px;
      font-size: 14px;
    }

    .controls button {
      padding: 10px 25px;
      background: linear-gradient(135deg, #00d9ff, #00ffff);
      color: #0a0e27;
      border: none;
      border-radius: 5px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
    }

    .stat-card {
      background: rgba(0, 255, 255, 0.05);
      padding: 25px;
      border-radius: 10px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      text-align: center;
      transition: all 0.3s;
    }

    .stat-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 30px rgba(0, 255, 255, 0.3);
    }

    .stat-card .label {
      font-size: 14px;
      color: #00d9ff;
      margin-bottom: 10px;
    }

    .stat-card .value {
      font-size: 32px;
      color: #00ffff;
      font-weight: bold;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .chart-container {
      background: rgba(0, 255, 255, 0.05);
      padding: 25px;
      border-radius: 10px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      margin-bottom: 30px;
      position: relative;
    }

    .chart-container h3 {
      color: #00ffff;
      margin-bottom: 20px;
      font-size: 20px;
      text-align: center;
    }

    .chart-wrapper {
      position: relative;
      height: 400px;
    }

    .loading {
      text-align: center;
      padding: 50px;
      color: #00d9ff;
      font-size: 18px;
    }

    .loading::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }

    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60%, 100% { content: '...'; }
    }

    .error {
      background: rgba(255, 0, 0, 0.1);
      border: 2px solid rgba(255, 0, 0, 0.5);
      padding: 20px;
      border-radius: 10px;
      color: #ff6b6b;
      text-align: center;
      margin: 20px 0;
    }

    .date-range-info {
      text-align: center;
      padding: 15px;
      background: rgba(0, 255, 255, 0.1);
      border-radius: 8px;
      margin-bottom: 20px;
      color: #00ffff;
      font-size: 16px;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
      gap: 30px;
      margin-bottom: 30px;
    }

    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
      
      .controls {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>📊 프로미카 로그 분석 대시보드</h1>
    <p>월간 로그 데이터 추이 및 통계 시각화</p>
  </div>

  <div class="controls">
    <div>
      <label>OpenSearch 인덱스:</label>
      <input type="text" id="indexName" value="contest_pm_task" placeholder="인덱스 이름">
    </div>
    <div>
      <label>시작 날짜:</label>
      <input type="date" id="startDate">
    </div>
    <div>
      <label>종료 날짜:</label>
      <input type="date" id="endDate">
    </div>
    <button onclick="loadDashboardData()">🔄 데이터 불러오기</button>
    <button onclick="refreshDashboard()">🔃 새로고침</button>
  </div>

  <div id="dateRangeInfo" class="date-range-info" style="display: none;"></div>

  <div id="loadingIndicator" class="loading" style="display: none;">데이터 로딩 중</div>
  <div id="errorMessage" class="error" style="display: none;"></div>

  <div class="stats-grid">
    <div class="stat-card">
      <div class="label">총 분석 일수</div>
      <div class="value" id="totalDays">-</div>
    </div>
    <div class="stat-card">
      <div class="label">총 요청 수</div>
      <div class="value" id="totalRequests">-</div>
    </div>
    <div class="stat-card">
      <div class="label">총 에러 수</div>
      <div class="value" id="totalErrors">-</div>
    </div>
    <div class="stat-card">
      <div class="label">일평균 요청</div>
      <div class="value" id="avgRequests">-</div>
    </div>
  </div>

  <div class="chart-container">
    <h3>📈 일별 요청 수 추이</h3>
    <div class="chart-wrapper">
      <canvas id="dailyRequestsChart"></canvas>
    </div>
  </div>

  <div class="chart-container">
    <h3>⚠️ 일별 에러 발생 추이</h3>
    <div class="chart-wrapper">
      <canvas id="dailyErrorsChart"></canvas>
    </div>
  </div>

  <div class="grid-2">
    <div class="chart-container">
      <h3>⏰ 시간대별 평균 사용량</h3>
      <div class="chart-wrapper">
        <canvas id="hourlyUsageChart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <h3>📱 인기 기기 TOP 10</h3>
      <div class="chart-wrapper">
        <canvas id="topDevicesChart"></canvas>
      </div>
    </div>
  </div>

  <div class="grid-2">
    <div class="chart-container">
      <h3>👥 활발한 사용자 TOP 10</h3>
      <div class="chart-wrapper">
        <canvas id="topUsersChart"></canvas>
      </div>
    </div>

    <div class="chart-container">
      <h3>🌍 지역별 사용 분포</h3>
      <div class="chart-wrapper">
        <canvas id="locationsChart"></canvas>
      </div>
    </div>
  </div>

  <script>
    const OPENSEARCH_API_BASE = "http://10.10.22.81:8080";
    let charts = {};

    // 페이지 로드 시 오늘 날짜를 종료일로, 30일 전을 시작일로 설정
    window.addEventListener('DOMContentLoaded', () => {
      const today = new Date();
      const thirtyDaysAgo = new Date(today);
      thirtyDaysAgo.setDate(today.getDate() - 30);

      document.getElementById('startDate').value = formatDate(thirtyDaysAgo);
      document.getElementById('endDate').value = formatDate(today);
    });

    function formatDate(date) {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    }

    function showLoading(show) {
      document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
    }

    function showError(message) {
      const errorDiv = document.getElementById('errorMessage');
      if (message) {
        errorDiv.textContent = message;
        errorDiv.style.display = 'block';
      } else {
        errorDiv.style.display = 'none';
      }
    }

    async function loadDashboardData() {
      showLoading(true);
      showError(null);

      const indexName = document.getElementById('indexName').value;
      const startDate = document.getElementById('startDate').value;
      const endDate = document.getElementById('endDate').value;

      if (!startDate || !endDate) {
        showError('시작 날짜와 종료 날짜를 선택하세요.');
        showLoading(false);
        return;
      }

      try {
        console.log('[Dashboard] 데이터 로딩 시작:', { indexName, startDate, endDate });

        // 날짜 범위 내의 모든 날짜에 대해 검색
        const allDocuments = [];
        const start = new Date(startDate);
        const end = new Date(endDate);
        
        const dateRangeInfo = document.getElementById('dateRangeInfo');
        dateRangeInfo.textContent = `📅 데이터 수집 중... (${startDate} ~ ${endDate})`;
        dateRangeInfo.style.display = 'block';

        // 날짜 범위 내의 각 날짜별로 검색
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
          const dateStr = formatDate(d);
          console.log('[Dashboard] 날짜별 검색:', dateStr);

          try {
            // keyword_search로 날짜 검색
            const response = await fetch(`${OPENSEARCH_API_BASE}/keyword_search`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                text: dateStr,
                index: indexName,
                k: 10
              })
            });

            if (response.ok) {
              const data = await response.json();
              if (data.result && data.result.length > 0) {
                // 결과가 문자열 배열인지 객체 배열인지 확인
                const docs = data.result.map(item => {
                  if (typeof item === 'string') {
                    try {
                      return JSON.parse(item);
                    } catch {
                      return null;
                    }
                  }
                  return item;
                }).filter(doc => doc !== null);

                // 해당 날짜의 문서만 필터링
                const dateDocs = docs.filter(doc => {
                  const logDate = doc.local_statistics?.logDate || doc.log_date || '';
                  return logDate === dateStr;
                });

                if (dateDocs.length > 0) {
                  allDocuments.push(dateDocs[0]); // 날짜당 하나의 문서만
                  console.log('[Dashboard] 발견:', dateStr, dateDocs[0]);
                }
              }
            }
          } catch (err) {
            console.warn('[Dashboard] 날짜 검색 실패:', dateStr, err);
          }

          // UI 업데이트
          dateRangeInfo.textContent = `📅 데이터 수집 중... ${allDocuments.length}일치 발견`;
        }

        console.log('[Dashboard] 총 데이터 수집 완료:', allDocuments.length, '일');

        if (allDocuments.length === 0) {
          showError(`${startDate}부터 ${endDate}까지 데이터가 없습니다.\n먼저 btn_learn_6으로 로그를 학습시켜주세요.\n\n💡 팁: 파일명을 "YYYYMMDD.log" 형식으로 업로드하세요 (예: 20251030.log)`);
          showLoading(false);
          return;
        }

        // 데이터 처리 및 시각화
        processAndVisualize(allDocuments, startDate, endDate);
        showLoading(false);

      } catch (error) {
        console.error('[Dashboard] 데이터 로딩 실패:', error);
        showError(`데이터 로딩 실패: ${error.message}\n\nOpenSearch 서버가 실행 중인지 확인하세요.`);
        showLoading(false);
      }
    }

    function processAndVisualize(documents, startDate, endDate) {
      console.log('[Dashboard] 데이터 처리 시작:', documents.length, '개 문서');

      // 날짜별로 정렬
      documents.sort((a, b) => {
        const dateA = a.local_statistics?.logDate || a.log_date || '';
        const dateB = b.local_statistics?.logDate || b.log_date || '';
        return dateA.localeCompare(dateB);
      });

      // 통계 계산
      const dailyData = [];
      let totalRequests = 0;
      let totalErrors = 0;
      const hourlyUsage = {};
      const devices = {};
      const users = {};
      const locations = {};

      documents.forEach(doc => {
        const stats = doc.local_statistics || doc.ai_analysis || doc;
        const logDate = stats.logDate || doc.log_date || '날짜 미상';
        const logDateFormatted = stats.logDateFormatted || doc.log_date_formatted || logDate;

        // 일별 데이터
        const requests = parseInt(stats.totalRequests || 0);
        const errors = (stats.errorSamples || stats.errors || []).length;

        dailyData.push({
          date: logDate,
          dateFormatted: logDateFormatted,
          requests: requests,
          errors: errors
        });

        totalRequests += requests;
        totalErrors += errors;

        // 시간대별 사용량 집계
        const hourly = stats.hourlyUsage || {};
        Object.entries(hourly).forEach(([hour, count]) => {
          hourlyUsage[hour] = (hourlyUsage[hour] || 0) + count;
        });

        // 기기 집계
        const topDevices = stats.topDevices || {};
        Object.entries(topDevices).forEach(([device, count]) => {
          devices[device] = (devices[device] || 0) + count;
        });

        // 사용자 집계
        const topUsers = stats.topUsers || {};
        Object.entries(topUsers).forEach(([user, count]) => {
          users[user] = (users[user] || 0) + count;
        });

        // 지역 집계
        const topLocations = stats.topLocations || {};
        Object.entries(topLocations).forEach(([loc, count]) => {
          locations[loc] = (locations[loc] || 0) + count;
        });
      });

      // 통계 카드 업데이트
      document.getElementById('totalDays').textContent = documents.length.toLocaleString();
      document.getElementById('totalRequests').textContent = totalRequests.toLocaleString();
      document.getElementById('totalErrors').textContent = totalErrors.toLocaleString();
      document.getElementById('avgRequests').textContent = Math.round(totalRequests / documents.length).toLocaleString();

      // 날짜 범위 정보 표시
      const dateRangeInfo = document.getElementById('dateRangeInfo');
      dateRangeInfo.textContent = `📅 분석 기간: ${startDate} ~ ${endDate} (${documents.length}일)`;
      dateRangeInfo.style.display = 'block';

      // 차트 생성
      createDailyRequestsChart(dailyData);
      createDailyErrorsChart(dailyData);
      createHourlyUsageChart(hourlyUsage);
      createTopDevicesChart(devices);
      createTopUsersChart(users);
      createLocationsChart(locations);

      console.log('[Dashboard] 시각화 완료');
    }

    function createDailyRequestsChart(dailyData) {
      const ctx = document.getElementById('dailyRequestsChart');
      if (charts.dailyRequests) charts.dailyRequests.destroy();

      charts.dailyRequests = new Chart(ctx, {
        type: 'line',
        data: {
          labels: dailyData.map(d => d.dateFormatted),
          datasets: [{
            label: '일별 요청 수',
            data: dailyData.map(d => d.requests),
            borderColor: '#00ffff',
            backgroundColor: 'rgba(0, 255, 255, 0.1)',
            borderWidth: 2,
            fill: true,
            tension: 0.4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createDailyErrorsChart(dailyData) {
      const ctx = document.getElementById('dailyErrorsChart');
      if (charts.dailyErrors) charts.dailyErrors.destroy();

      charts.dailyErrors = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: dailyData.map(d => d.dateFormatted),
          datasets: [{
            label: '일별 에러 수',
            data: dailyData.map(d => d.errors),
            backgroundColor: 'rgba(255, 99, 132, 0.6)',
            borderColor: '#ff6b6b',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createHourlyUsageChart(hourlyUsage) {
      const ctx = document.getElementById('hourlyUsageChart');
      if (charts.hourlyUsage) charts.hourlyUsage.destroy();

      const hours = Array.from({ length: 24 }, (_, i) => String(i).padStart(2, '0'));
      const data = hours.map(h => hourlyUsage[h] || 0);

      charts.hourlyUsage = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: hours.map(h => `${h}시`),
          datasets: [{
            label: '시간대별 사용량',
            data: data,
            borderColor: '#00ffff',
            backgroundColor: 'rgba(0, 255, 255, 0.2)',
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            r: { 
              ticks: { color: '#00d9ff' }, 
              grid: { color: 'rgba(0, 255, 255, 0.1)' },
              pointLabels: { color: '#00d9ff' }
            }
          }
        }
      });
    }

    function createTopDevicesChart(devices) {
      const ctx = document.getElementById('topDevicesChart');
      if (charts.topDevices) charts.topDevices.destroy();

      const sorted = Object.entries(devices).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.topDevices = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: sorted.map(d => d[0]),
          datasets: [{
            data: sorted.map(d => d[1]),
            backgroundColor: [
              '#00ffff', '#00d9ff', '#00b3cc', '#008c99', '#006666',
              '#ffaa00', '#ff8800', '#ff6600', '#ff4400', '#ff2200'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' }, position: 'right' }
          }
        }
      });
    }

    function createTopUsersChart(users) {
      const ctx = document.getElementById('topUsersChart');
      if (charts.topUsers) charts.topUsers.destroy();

      const sorted = Object.entries(users).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.topUsers = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: sorted.map(u => u[0]),
          datasets: [{
            label: '사용량',
            data: sorted.map(u => u[1]),
            backgroundColor: 'rgba(0, 255, 255, 0.6)',
            borderColor: '#00ffff',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          plugins: {
            legend: { labels: { color: '#00ffff' } }
          },
          scales: {
            x: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } },
            y: { ticks: { color: '#00d9ff' }, grid: { color: 'rgba(0, 255, 255, 0.1)' } }
          }
        }
      });
    }

    function createLocationsChart(locations) {
      const ctx = document.getElementById('locationsChart');
      if (charts.locations) charts.locations.destroy();

      const sorted = Object.entries(locations).sort((a, b) => b[1] - a[1]).slice(0, 10);

      charts.locations = new Chart(ctx, {
        type: 'pie',
        data: {
          labels: sorted.map(l => `지역 ${l[0]}`),
          datasets: [{
            data: sorted.map(l => l[1]),
            backgroundColor: [
              '#00ffff', '#00d9ff', '#00b3cc', '#008c99', '#006666',
              '#ffaa00', '#ff8800', '#ff6600', '#ff4400', '#ff2200'
            ]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { labels: { color: '#00ffff' }, position: 'right' }
          }
        }
      });
    }

    function refreshDashboard() {
      loadDashboardData();
    }
  </script>
</body>
</html>
