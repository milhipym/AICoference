<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
<title>프로미카 로그 모니터링</title>
<link rel="stylesheet" href="css/common.css" />
<link rel="stylesheet" href="css/contents.css" />
<link rel="stylesheet" href="css/modal.css" />
<link rel="stylesheet" href="css/card.css" />
<link rel="stylesheet" href="css/layout-erroranalyze.css" />
<link rel="stylesheet" href="css/layout-searchlist.css" />
<link rel="stylesheet" href="css/layout-detailanalyze.css" />
</head>
<body>
  <div class="cockpit">
    <!-- 헤더 -->
    <div class="cockpit-header">
      <h1>◈ LOG MONITORING SYSTEM ◈</h1>
      <p class="subtitle">REAL-TIME ANALYSIS DASHBOARD</p>
    </div>

    <!-- 메인 모니터 (대형 차트 화면) -->
    <div class="main-monitor">
      <div class="monitor-header">
        <span class="monitor-title">◆ TEMPORAL LOG DISTRIBUTION</span>
        <div class="monitor-indicators">
          <span class="indicator active"></span>
          <span class="indicator"></span>
          <span class="indicator"></span>
        </div>
      </div>
      <div class="monitor-body">
        <div id="chart"></div>
        <progress id="prog" max="100" value="0"></progress>
        <div id="status">
          <span class="status-text">SYSTEM READY - AWAITING LOG FILE</span>
        </div>
      </div>
    </div>

    <!-- 하단 콘솔 패널 그리드 -->
    <div class="console-grid">
      <!-- 파일 로드 패널 -->
      <div class="console-panel">
        <div class="panel-header">▣ FILE LOADER</div>
        <div class="panel-body">
          <div class="upload-zone" id="uploadZone">
            <input id="file" type="file" accept=".log,.txt" />
            <label for="file" class="upload-btn">SELECT FILE</label>
            <span id="file-name">NO FILE LOADED</span>
          </div>
          <div class="file-history">
            <div class="history-header">
              RECENT FILES
              <button class="history-popup-btn" onclick="openHistoryPopup()" title="전체 히스토리 보기">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                  <line x1="9" y1="9" x2="15" y2="9"></line>
                  <line x1="9" y1="15" x2="15" y2="15"></line>
                </svg>
              </button>
            </div>
            <div id="historyList" class="history-list">
              <div class="history-empty">NO HISTORY</div>
            </div>
          </div>
        </div>
      </div>

      <!-- 검색 제어 패널 -->
      <div class="console-panel">
        <div class="panel-header">▣ SEARCH CONTROL</div>
        <div class="panel-body">
          <div class="control-group">
            <label>추천 키워드</label>
            <div class="keyword-chips">
              <button class="chip chip-info" onclick="setSearchWord('INFO')">INFO</button>
              <button class="chip chip-error" onclick="setSearchWord('Exception')">Exception</button>
              <button class="chip chip-fatal" onclick="setSearchWord('FATAL')">FATAL</button>
            </div>
          </div>
          <div class="control-group">
            <label>PATTERN</label>
            <input type="text" id="searchWord" placeholder="INFO, Exception, WARN..." value="INFO">
          </div>
          <button class="btn primary" id="btnSearch" onclick="doSearch()">EXECUTE SEARCH</button>
        </div>
      </div>

      <!-- 분석 옵션 패널 -->
      <div class="console-panel">
        <div class="panel-header">▣ ANALYSIS OPTIONS</div>
        <div class="panel-body">
          <button class="btn btn-cyber-neon" id="btnDetail" onclick="openDetailPopup()">종합 분석</button>
          <button class="btn btn-cyber-neon" id="btnErrorAnal" onclick="openErrorPopup()">오류 분석</button>
          <button class="btn btn-cyber-neon" id="btnSplit" onclick="doSplit()">FILE SPLIT</button>
        </div>
      </div>

      <!-- 로그 뷰어 패널 -->
      <div class="console-panel log-viewer-half">
        <div class="panel-header">▣ LOG VIEWER</div>
        <div class="panel-body">
          <div id="preview"></div>
        </div>
      </div>


    </div>
  </div>

  <!-- 종합분석 팝업 -->
  <div id="detailPopup" class="detail-popup">
    <div class="detail-popup-content">
      <div class="detail-popup-header">
        <h2>◆ LOG STATISTICS ANALYSIS ◆</h2>
        
        <!-- 숨겨진 학습 버튼들 -->
        <div class="hidden-learning-buttons">
          <button id="btn_learn_1" class="hidden-btn" title="인덱스 생성">1</button>
          <button id="btn_learn_2" class="hidden-btn" title="임베딩 생성">2</button>
          <button id="btn_learn_3" class="hidden-btn" title="데이터 삽입">3</button>
          <button id="btn_learn_4" class="hidden-btn" title="예약 기능">4</button>
          <button id="btn_learn_5" class="hidden-btn" title="예약 기능">5</button>
          <button id="btn_learn_6" class="hidden-btn" title="로컬 전처리 분석">6</button>
        </div>
        
        <button class="detail-close-btn" onclick="closeDetailPopup()">✕ CLOSE</button>
      </div>
      
      <!-- 로딩 애니메이션 -->
      <div id="analysisLoading" class="analysis-loading">
        <!-- 자비스 스타일 데이터 스트림 배경 -->
        <div class="jarvis-data-streams">
          <div class="data-stream stream-1"></div>
          <div class="data-stream stream-2"></div>
          <div class="data-stream stream-3"></div>
          <div class="data-stream stream-4"></div>
        </div>
        
        <!-- 움직이는 라인들 -->
        <div class="jarvis-lines">
          <div class="scan-line line-1"></div>
          <div class="scan-line line-2"></div>
          <div class="scan-line line-3"></div>
        </div>
        
        <!-- 추가 회전 링들 -->
        <div class="jarvis-rings">
          <div class="ring ring-1"></div>
          <div class="ring ring-2"></div>
          <div class="ring ring-3"></div>
        </div>
        
        <div class="loading-spinner"></div>
        <div class="loading-text">ANALYZING LOG DATA...</div>
        <div class="loading-progress" id="loadingProgress">0%</div>
      </div>
      
      <div id="detailContent" style="display:none;">
        <div class="detail-section">
          <h3>? Overall Statistics</h3>
          <div class="detail-stats-grid">
            <div class="stat-card">
              <h4>Total Requests</h4>
              <div class="stat-value" id="totalRequests">0</div>
            </div>
            <div class="stat-card">
              <h4>Exception Count</h4>
              <div class="stat-value" id="errorCount" style="color: #ff6666;">0</div>
            </div>
            <div class="stat-card">
              <h4>Analysis Duration</h4>
              <div class="stat-value" id="analysisDuration" style="font-size: 18px;">-</div>
            </div>
          </div>
        </div>

        <div class="detail-section">
          <h3>? TOP 5 UX_ Requests</h3>
          <div id="topRequests"></div>
        </div>

        <div class="detail-section">
          <h3>⚠️ Exceptions</h3>
          <div id="errorLogs" class="error-list"></div>
          <div id="errorPagination" class="error-pagination" style="display:none;">
            <button class="btn-page" onclick="prevErrorPage()">◀ PREV</button>
            <span class="page-info" id="errorPageInfo">1 / 1</span>
            <button class="btn-page" onclick="nextErrorPage()">NEXT ▶</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="js/marked.min.js"></script>
  <script src="js/jszip.min.js"></script>
  <script src="js/logWorkerSource.js"></script>
  <script src="js/plotly-3.1.0.min.js"></script>
  <script src="js/modal.js"></script>
  <script src="js/util/fileUtil.js"></script>
  <script src="js/util/stringUtil.js"></script>
  <script src="js/model/errorAnalyzeViewModel.js"></script>
  <script src="js/model/searchListViewModel.js"></script>
  <script src="js/model/detailInfoViewModel.js"></script>
  <script src="js/main.js"></script>
  <script src="js/view/erroranalyze.js"></script>
  <script src="js/view/searchList.js"></script>
  <script src="js/view/detailInfo.js"></script>
  
  <script>
    const uploadZone = document.getElementById('uploadZone');
    const fileInputEl = document.getElementById('file');

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('dragover');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('dragover');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      uploadZone.classList.remove('dragover');
      
      const files = e.dataTransfer.files;
      if (files.length > 0) {
        const f = files[0];
        window.logfile = f;
        document.getElementById('file-name').textContent = f.name;
        
        if (typeof chartDragClear === 'function') {
          chartDragClear();
        }
        window.timeRangeSize = 24;
        
        // 히스토리에 추가
        if (typeof addToHistory === 'function') {
          addToHistory(f);
        }
      }
    });

    fileInputEl.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (f) {
        document.getElementById('file-name').textContent = f.name;
        
        // 히스토리에 추가
        if (typeof addToHistory === 'function') {
          addToHistory(f);
        }
      }
    });

    // 추천 키워드 클릭 시 검색어 자동 입력
    function setSearchWord(keyword) {
      document.getElementById('searchWord').value = keyword;
      document.getElementById('searchWord').focus();
    }

    // IndexedDB 설정
    const DB_NAME = 'LogAnalyzerDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'logfiles';
    const FILE_HISTORY_KEY = 'logfile_history';
    const MAX_HISTORY = 15;
    let db = null;

    // IndexedDB 초기화
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };
        
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'id' });
          }
        };
      });
    }

    // IndexedDB에 파일 저장
    async function saveFileToIndexedDB(file) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const id = `${file.name}_${file.size}`;
        
        const request = store.put({ id, file, timestamp: Date.now() });
        request.onsuccess = () => resolve(id);
        request.onerror = () => reject(request.error);
      });
    }

    // IndexedDB에서 파일 불러오기
    async function loadFileFromIndexedDB(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readonly');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.get(id);
        
        request.onsuccess = () => {
          if (request.result) {
            resolve(request.result.file);
          } else {
            resolve(null);
          }
        };
        request.onerror = () => reject(request.error);
      });
    }

    // IndexedDB에서 파일 삭제
    async function deleteFileFromIndexedDB(id) {
      if (!db) await initDB();
      
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([STORE_NAME], 'readwrite');
        const store = transaction.objectStore(STORE_NAME);
        const request = store.delete(id);
        
        request.onsuccess = () => resolve();
        request.onerror = () => reject(request.error);
      });
    }

    // 히스토리 불러오기
    function loadHistory() {
      try {
        const history = localStorage.getItem(FILE_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
      } catch (e) {
        return [];
      }
    }

    // 히스토리 저장
    function saveHistory(history) {
      try {
        localStorage.setItem(FILE_HISTORY_KEY, JSON.stringify(history));
      } catch (e) {
        console.error('Failed to save history:', e);
      }
    }

    // 히스토리에 파일 추가
    async function addToHistory(file) {
      let history = loadHistory();
      
      // 중복 제거 (같은 파일명과 크기)
      history = history.filter(item => 
        !(item.name === file.name && item.size === file.size)
      );
      
      // 새 파일을 맨 앞에 추가
      history.unshift({
        name: file.name,
        size: file.size,
        timestamp: Date.now()
      });
      
      // 최대 개수 제한
      history = history.slice(0, MAX_HISTORY);
      
      saveHistory(history);
      
      // IndexedDB에 파일 저장
      try {
        await saveFileToIndexedDB(file);
      } catch (e) {
        console.error('Failed to save file to IndexedDB:', e);
      }
      
      updateHistoryUI();
    }

    // 히스토리에서 삭제
    function removeFromHistory(index) {
      let history = loadHistory();
      history.splice(index, 1);
      saveHistory(history);
      updateHistoryUI();
    }

    // 파일 크기 포맷
    function formatFileSize(bytes) {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      return (bytes / (1024 * 1024 * 1024)).toFixed(1) + ' GB';
    }

    // 히스토리 파일 클릭 시 로드
    async function loadFromHistory(index) {
      const history = loadHistory();
      const item = history[index];
      
      if (!item) return;
      
      // IndexedDB에서 파일 불러오기
      const fileId = `${item.name}_${item.size}`;
      const file = await loadFileFromIndexedDB(fileId);
      
      if (file) {
        // 파일 자동 로드
        window.logfile = file;
        mainModel.logfile = file;
        document.getElementById('file-name').textContent = file.name;
        
        if (typeof chartDragClear === 'function') {
          chartDragClear();
        }
        window.timeRangeSize = 24;
        
        // 검색 버튼 깜빡임 추가
        const searchBtn = document.getElementById('btnSearch');
        if (searchBtn) {
          searchBtn.classList.add('btn-blink');
        }
      } else {
        // 파일이 IndexedDB에 없음
        alert(`파일을 찾을 수 없습니다.\n"${item.name}" 파일을 다시 선택해주세요.`);
        await deleteFileFromIndexedDB(fileId);
        removeFromHistory(index);
      }
    }

    // 히스토리 UI 업데이트 (최신 1개만 표시)
    function updateHistoryUI() {
      const history = loadHistory();
      const historyList = document.getElementById('historyList');
      
      if (history.length === 0) {
        historyList.innerHTML = '<div class="history-empty">NO HISTORY</div>';
        return;
      }
      
      // 최신 1개만 표시
      const latestItem = history[0];
      historyList.innerHTML = `
        <div class="history-item">
          <span class="history-item-name" title="${latestItem.name}" onclick="loadFromHistory(0)">${latestItem.name}</span>
          <span class="history-item-size">${formatFileSize(latestItem.size)}</span>
          <button class="history-item-delete" onclick="removeFromHistory(0)">×</button>
        </div>
      `;
    }

    // 전역 모달 인스턴스
    let historyModal = null;

    // 히스토리 팝업 열기
    function openHistoryPopup() {
      const history = loadHistory();
      
      if (history.length === 0) {
        alert('저장된 파일 히스토리가 없습니다.');
        return;
      }
      
      const popupContent = `
        <div class="history-popup-header">
          <h3>파일 히스토리 (${history.length}개)</h3>
          <button class="popup-close-btn" onclick="closeHistoryPopup()">×</button>
        </div>
        <div class="history-popup-list">
          ${history.map((item, index) => `
            <div class="history-popup-item">
              <div class="popup-item-info" onclick="loadFromHistoryPopup(${index})">
                <span class="popup-item-name" title="${item.name}">${item.name}</span>
                <span class="popup-item-size">${formatFileSize(item.size)}</span>
              </div>
              <button class="popup-item-delete" onclick="removeFromHistoryPopup(${index})">삭제</button>
            </div>
          `).join('')}
        </div>
      `;
      
      // Modal 인스턴스 생성
      historyModal = new Modal({
        size: 'md',
        title: '',
        closeOnEsc: true,
        closeOnOverlay: true
      });
      
      historyModal.setContent(popupContent);
      historyModal.open();
    }

    // 팝업 닫기
    function closeHistoryPopup() {
      if (historyModal) {
        historyModal.close();
        historyModal = null;
      }
    }

    // 팝업에서 파일 로드
    async function loadFromHistoryPopup(index) {
      const history = loadHistory();
      const item = history[index];
      
      if (!item) return;
      
      // IndexedDB에서 파일 불러오기
      const fileId = `${item.name}_${item.size}`;
      const file = await loadFileFromIndexedDB(fileId);
      
      if (file) {
        // 파일 자동 로드
        window.logfile = file;
        mainModel.logfile = file
        document.getElementById('file-name').textContent = file.name;
        
        if (typeof chartDragClear === 'function') {
          chartDragClear();
        }
        window.timeRangeSize = 24;
        
        // 검색 버튼 깜빡임 추가
        const searchBtn = document.getElementById('btnSearch');
        if (searchBtn) {
          searchBtn.classList.add('btn-blink');
        }
        
        // 팝업 닫기
        closeHistoryPopup();
      } else {
        // 파일이 IndexedDB에 없음
        alert(`파일을 찾을 수 없습니다.\n"${item.name}" 파일을 다시 선택해주세요.`);
        await removeFromHistoryPopup(index);
      }
    }

    // 팝업에서 파일 삭제
    async function removeFromHistoryPopup(index) {
      const history = loadHistory();
      const item = history[index];
      
      if (item) {
        const fileId = `${item.name}_${item.size}`;
        await deleteFileFromIndexedDB(fileId);
      }
      
      removeFromHistory(index);
      
      // 팝업 내용 갱신
      const newHistory = loadHistory();
      if (newHistory.length === 0) {
        closeHistoryPopup();
        return;
      }
      
      // 팝업 다시 열기 (갱신)
      closeHistoryPopup();
      setTimeout(() => openHistoryPopup(), 100);
    }

    // 페이지 로드 시 IndexedDB 초기화
    (async function() {
      await initDB();
      updateHistoryUI();
    })();

    // 초기 히스토리 로드
    updateHistoryUI();

    // 로그 분석 데이터 저장
    let logAnalysisData = {
      totalRequests: 0,
      uxRequests: {},
      errors: [],
      totalErrorCount: 0,
      timeStart: null,
      timeEnd: null
    };

    // 에러 페이지네이션
    let currentErrorPage = 1;
    const ERRORS_PER_PAGE = 20;

    // 종합분석 팝업 열기
    async function openDetailPopup() {
      if (!mainModel.logfile) {
        alert("로그 파일을 업로드 후 'EXECUTE SEARCH' 버튼을 누르세요 !!");
        return;
      }

      // 검색 완료 여부 확인
      if (!mainModel.searchObj || !mainModel.searchObj.searchLineStartByteArray) {
        alert("로그 파일을 업로드 후 'EXECUTE SEARCH' 버튼을 누르세요 !!");
        return;
      }

      const popup = document.getElementById('detailPopup');
      popup.classList.add('active');
      
      // 로딩 표시, 결과 숨김
      document.getElementById('analysisLoading').style.display = 'flex';
      document.getElementById('detailContent').style.display = 'none';
      document.getElementById('loadingProgress').textContent = '0%';
      
      // 로그 분석 시작
      await analyzeLogFile();
      
      // 로딩 숨김, 결과 표시
      document.getElementById('analysisLoading').style.display = 'none';
      document.getElementById('detailContent').style.display = 'block';
      
      // 결과 표시
      currentErrorPage = 1;
      displayAnalysisResults();
    }

    // 종합분석 팝업 닫기
    function closeDetailPopup() {
      const popup = document.getElementById('detailPopup');
      popup.classList.remove('active');
    }

    // 로그 파일 분석 (청크 방식 - 대용량 파일 지원)
    async function analyzeLogFile() {
      const file = mainModel.logfile;
      if (!file) return;

      // 분석 데이터 초기화
      logAnalysisData = {
        totalRequests: 0,
        uxRequests: {},
        errors: [],
        totalErrorCount: 0,
        timeStart: null,
        timeEnd: null
      };

      const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB씩 읽기
      let offset = 0;
      let lineNumber = 0;
      let leftover = '';

      // 진행상황 표시
      const loadingProgress = document.getElementById('loadingProgress');
      
      while (offset < file.size) {
        const chunkEnd = Math.min(offset + CHUNK_SIZE, file.size);
        const chunk = file.slice(offset, chunkEnd);
        const text = await chunk.text();
        const combined = leftover + text;
        
        const lines = combined.split('\n');
        
        // 마지막 라인은 다음 청크로 이월 (불완전할 수 있음)
        if (chunkEnd < file.size) {
          leftover = lines.pop() || '';
        } else {
          leftover = '';
        }

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          lineNumber++;

          // _BIZREQUEST 추출
          if (line.includes('_BIZREQUEST')) {
            logAnalysisData.totalRequests++;
            
            // UX_ 요청 추출
            const uxMatch = line.match(/_BIZREQUEST[:\s]+([A-Z_0-9]+)/);
            if (uxMatch && uxMatch[1].startsWith('UX_')) {
              const reqName = uxMatch[1];
              logAnalysisData.uxRequests[reqName] = (logAnalysisData.uxRequests[reqName] || 0) + 1;
            }
          }

          // Exception 추출 (Exception, Error:) - 멀티라인 지원
          if (line.includes('Exception') || line.includes('Error:')) {
            logAnalysisData.totalErrorCount++;
            
            // 상세 내용은 최대 1000개만 저장 (페이지네이션용)
            if (logAnalysisData.errors.length < 1000) {
              // 타임스탬프 추출
              const timeMatch = line.match(/(\d{2}:\d{2}:\d{2})/);
              const timestamp = timeMatch ? timeMatch[1] : '';
              
              // Exception 타입
              let errorType = 'Exception';
              
              // Exception 본문 + 스택 트레이스 수집
              let fullErrorContent = line.trim();
              let additionalLines = 0;
              for (let j = i + 1; j < Math.min(i + 50, lines.length); j++) {
                const nextLine = lines[j].trim();
                // 스택 트레이스 라인인지 확인
                if (nextLine.startsWith('at ') || 
                    nextLine.startsWith('Caused by:') || 
                    nextLine.startsWith('Suppressed:') || 
                    nextLine.startsWith('...')) {
                  fullErrorContent += '\n' + nextLine;
                  additionalLines++;
                } else if (!nextLine || 
                          /^\d{2}:\d{2}:\d{2}/.test(nextLine) || 
                          /^(?:[A-Z]+\s+)?\[?\d{4}[-\/]\d{2}[-\/]\d{2}[\sT]\d{2}:\d{2}:\d{2}/.test(nextLine)) {
                  break;
                } else {
                  break;
                }
              }
              
              logAnalysisData.errors.push({
                line: lineNumber,
                timestamp: timestamp,
                errorType: errorType,
                content: fullErrorContent,
                lines: additionalLines + 1
              });
              
              i += additionalLines;
              lineNumber += additionalLines;
            }
          }

          // 시간 범위 추출
          const timeMatch = line.match(/(\d{2}:\d{2}:\d{2})/);
          if (timeMatch) {
            if (!logAnalysisData.timeStart) {
              logAnalysisData.timeStart = timeMatch[1];
            }
            logAnalysisData.timeEnd = timeMatch[1];
          }
        }

        offset = chunkEnd;
        
        const percent = Math.min(Math.floor((offset / file.size) * 100), 100);
        if (loadingProgress) {
          loadingProgress.textContent = `${percent}%`;
        }
      }
    }

    // 분석 결과 표시
    function displayAnalysisResults() {
      document.getElementById('totalRequests').textContent = logAnalysisData.totalRequests.toLocaleString();
      document.getElementById('errorCount').textContent = logAnalysisData.totalErrorCount.toLocaleString();
      
      if (logAnalysisData.timeStart && logAnalysisData.timeEnd) {
        document.getElementById('analysisDuration').textContent = 
          `${logAnalysisData.timeStart} ~ ${logAnalysisData.timeEnd}`;
      }

      // TOP 5 UX_ 요청
      const topRequests = Object.entries(logAnalysisData.uxRequests)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5);
      
      const topRequestsHTML = topRequests.map((item, index) => `
        <div class="stat-card">
          <h4>${index + 1}. ${item[0]}</h4>
          <div class="stat-value" style="font-size: 20px;">${item[1].toLocaleString()} 회</div>
        </div>
      `).join('');
      
      document.getElementById('topRequests').innerHTML = `
        <div class="detail-stats-grid">${topRequestsHTML || '<p style="color: #888;">UX_ 요청이 없습니다.</p>'}</div>
      `;

      displayErrorPage();
    }

    // 에러 페이지 표시
    function displayErrorPage() {
      const totalPages = Math.ceil(logAnalysisData.errors.length / ERRORS_PER_PAGE);
      const startIdx = (currentErrorPage - 1) * ERRORS_PER_PAGE;
      const endIdx = Math.min(startIdx + ERRORS_PER_PAGE, logAnalysisData.errors.length);
      
      const errorHTML = logAnalysisData.errors.slice(startIdx, endIdx).map(err => {
        const errorColor = '#ff9900';
        return `
          <div class="error-item">
            <div class="error-header">
              <span class="error-type" style="color: ${errorColor};">◆ ${err.errorType}</span>
              <span class="error-line">Line ${err.line}</span>
              ${err.timestamp ? `<span class="error-time">⏱ ${err.timestamp}</span>` : ''}
            </div>
            <div class="error-content">${err.content}</div>
          </div>
        `;
      }).join('');
      
      const errorWarning = logAnalysisData.totalErrorCount > logAnalysisData.errors.length
        ? `<p style="color: #ff6b9d; margin-top: 10px;">⚠️ 총 ${logAnalysisData.totalErrorCount.toLocaleString()}개 Exception 중 ${logAnalysisData.errors.length.toLocaleString()}개까지 저장되었습니다.</p>` 
        : '';
      
      document.getElementById('errorLogs').innerHTML = (errorHTML || 
        '<p style="color: #888;">Exception이 발견되지 않았습니다.</p>') + errorWarning;
      
      const pagination = document.getElementById('errorPagination');
      if (logAnalysisData.errors.length > ERRORS_PER_PAGE) {
        pagination.style.display = 'flex';
        document.getElementById('errorPageInfo').textContent = `${currentErrorPage} / ${totalPages}`;
        
        const prevBtn = pagination.querySelector('button:first-child');
        const nextBtn = pagination.querySelector('button:last-child');
        
        prevBtn.disabled = currentErrorPage === 1;
        nextBtn.disabled = currentErrorPage === totalPages;
      } else {
        pagination.style.display = 'none';
      }
    }

    // 이전 페이지
    function prevErrorPage() {
      if (currentErrorPage > 1) {
        currentErrorPage--;
        displayErrorPage();
      }
    }

    // 다음 페이지
    function nextErrorPage() {
      const totalPages = Math.ceil(logAnalysisData.errors.length / ERRORS_PER_PAGE);
      if (currentErrorPage < totalPages) {
        currentErrorPage++;
        displayErrorPage();
      }
    }

    // 로그 분석 완료 시 종합분석 버튼 표시
    window.addEventListener('message', function(e) {
      if (e.data && e.data.cmd === 'complete') {
        const detailBtn = document.getElementById('btnDetail');
        if (detailBtn) {
          detailBtn.style.display = 'block';
        }
      }
    });

    // ==================== 학습 기능 API ====================
    // 폐쇄망 직접 통신
    const OPENSEARCH_API_BASE = "http://10.10.22.81:8080";
    const DEFAULT_INDEX = "contest_pm_task";

    // 진행률 팝업 생성
    function createProgressPopup(fileName, fileSizeMB) {
      const popup = document.createElement('div');
      popup.id = 'progressPopup';
      popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      popup.innerHTML = `
        <div style="
          background: #0a0e27;
          border: 2px solid #00ffff;
          border-radius: 10px;
          padding: 40px;
          min-width: 600px;
          box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        ">
          <h2 style="color: #00ffff; margin-top: 0; text-align: center;">
            ◆ 전체 파일 분석 중 ◆
          </h2>
          <p style="color: #888; text-align: center; margin-bottom: 30px;">
            파일: ${fileName} (${fileSizeMB.toFixed(2)} MB)
          </p>
          
          <div style="margin: 20px 0;">
            <div style="
              background: #000;
              border: 1px solid #00ffff;
              border-radius: 10px;
              height: 30px;
              overflow: hidden;
              position: relative;
            ">
              <div id="progressBar" style="
                background: linear-gradient(90deg, #00ff00, #00ffff);
                height: 100%;
                width: 0%;
                transition: width 0.3s;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
              "></div>
              <div id="progressText" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #fff;
                font-weight: bold;
                text-shadow: 0 0 5px #000;
              ">0%</div>
            </div>
          </div>
          
          <p id="progressStatus" style="
            color: #0f0;
            text-align: center;
            margin: 20px 0;
            min-height: 20px;
          ">준비 중...</p>
          
          <div id="progressDetails" style="
            background: #000;
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 20px 0;
          "></div>
          
          <div style="display: flex; justify-content: center; gap: 20px; margin-top: 30px;">
            <button id="pauseAnalysisBtn" style="
              padding: 12px 30px;
              background: linear-gradient(90deg, #ffaa00, #ff8800);
              color: #000;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
            ">⏸ 일시정지</button>
            <button id="cancelAnalysisBtn" style="
              padding: 12px 30px;
              background: linear-gradient(90deg, #ff6b6b, #ff0000);
              color: #fff;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            ">✕ 취소</button>
          </div>
        </div>
      `;
      
      return popup;
    }

    // 진행률 업데이트
    function updateProgressPopup(current, total, status) {
      const percentage = Math.floor((current / total) * 100);
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const progressStatus = document.getElementById('progressStatus');
      const progressDetails = document.getElementById('progressDetails');
      
      if (progressBar) progressBar.style.width = percentage + '%';
      if (progressText) progressText.textContent = percentage + '%';
      if (progressStatus) progressStatus.textContent = status;
      
      // 상세 로그 추가
      if (progressDetails) {
        const now = new Date().toLocaleTimeString();
        const logLine = document.createElement('div');
        logLine.textContent = `[${now}] ${status}`;
        progressDetails.appendChild(logLine);
        progressDetails.scrollTop = progressDetails.scrollHeight;
      }
    }

    // 임베딩 생성 함수
    async function embed_query(text) {
      console.log('[embed_query] 임베딩 생성 시작:', text.substring(0, 50) + '...');
      
      // 상세 디버깅 정보
      console.log('[DEBUG-EMBED] ===== Execution Context =====');
      console.log('[DEBUG-EMBED] window.location.href:', window.location.href);
      console.log('[DEBUG-EMBED] window.location.origin:', window.location.origin);
      console.log('[DEBUG-EMBED] OPENSEARCH_API_BASE:', OPENSEARCH_API_BASE);
      console.log('[DEBUG-EMBED] Target URL:', `${OPENSEARCH_API_BASE}/embed`);
      console.log('[DEBUG-EMBED] =============================');
      
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/embed`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: text })
        });
        
        console.log('[DEBUG-EMBED] Response status:', response.status);
        console.log('[DEBUG-EMBED] Response ok:', response.ok);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('[embed_query] 임베딩 생성 완료, 벡터 길이:', data.embedding?.length);
        return data.embedding;
      } catch (error) {
        console.error('[embed_query] 임베딩 생성 실패:', error);
        console.error('[DEBUG-EMBED] Error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        alert('임베딩 생성 실패: ' + error.message);
        return null;
      }
    }

    // LLM API 호출 함수
    async function call_llm_api(prompt, model, silentMode = false) {
      console.log('[call_llm_api] LLM 호출 시작, model:', model, 'silentMode:', silentMode);
      
      // 상세 디버깅 정보
      console.log('[DEBUG] ===== Execution Context =====');
      console.log('[DEBUG] window.location.href:', window.location.href);
      console.log('[DEBUG] window.location.origin:', window.location.origin);
      console.log('[DEBUG] window.location.protocol:', window.location.protocol);
      console.log('[DEBUG] document.location.origin:', document.location.origin);
      console.log('[DEBUG] OPENSEARCH_API_BASE:', OPENSEARCH_API_BASE);
      console.log('[DEBUG] Target URL:', `${OPENSEARCH_API_BASE}/vllm_chat`);
      console.log('[DEBUG] Request body:', JSON.stringify({ text: prompt.substring(0, 100) + '...', model: model, limit: 4096 }));
      console.log('[DEBUG] =============================');
      
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/vllm_chat`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ 
            text: prompt, 
            model: model,
            limit: 4096
          })
        });
        
        console.log('[DEBUG] Response received');
        console.log('[DEBUG] Response status:', response.status);
        console.log('[DEBUG] Response statusText:', response.statusText);
        console.log('[DEBUG] Response headers:', [...response.headers.entries()]);
        console.log('[DEBUG] Response ok:', response.ok);
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('[call_llm_api] LLM 응답 받음, 길이:', data.content?.length);
        return data.content;
      } catch (error) {
        console.error('[call_llm_api] LLM 호출 실패:', error);
        console.error('[DEBUG] Error details:', {
          name: error.name,
          message: error.message,
          stack: error.stack
        });
        
        // silentMode가 false일 때만 alert 표시
        if (!silentMode) {
          alert('LLM 호출 실패: ' + error.message);
        }
        return null;
      }
    }

    // JSON 결과 팝업 생성
    function createJsonResultPopup(jsonResult, fileName) {
      const popup = document.createElement('div');
      popup.id = 'jsonResultPopup';
      popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      popup.innerHTML = `
        <div style="
          background: #0a0e27;
          border: 2px solid #00ffff;
          border-radius: 10px;
          padding: 30px;
          max-width: 90%;
          max-height: 90%;
          overflow: auto;
          box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        ">
          <h2 style="color: #00ffff; margin-top: 0; text-align: center;">
            ◆ AI 로그 분석 결과 ◆
          </h2>
          <p style="color: #888; text-align: center; margin-bottom: 20px;">
            파일: ${fileName}
          </p>
          <pre style="
            background: #000;
            color: #0f0;
            padding: 20px;
            border-radius: 5px;
            overflow: auto;
            max-height: 50vh;
            font-size: 12px;
            border: 1px solid #00ffff;
          ">${JSON.stringify(jsonResult, null, 2)}</pre>
          <div style="display: flex; justify-content: center; gap: 20px; margin-top: 30px;">
            <button id="learnJsonBtn" style="
              padding: 12px 30px;
              background: linear-gradient(90deg, #00ff00, #00cc00);
              color: #000;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
            ">학습 하기</button>
            <button id="closeJsonBtn" style="
              padding: 12px 30px;
              background: linear-gradient(90deg, #ff6b6b, #ff0000);
              color: #fff;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            ">닫기</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(popup);
      
      // 닫기 버튼 이벤트
      document.getElementById('closeJsonBtn').addEventListener('click', () => {
        popup.remove();
      });
      
      // 학습 하기 버튼 이벤트
      document.getElementById('learnJsonBtn').addEventListener('click', async () => {
        console.log('[learnJsonBtn] JSON 학습 시작');
        
        const learnBtn = document.getElementById('learnJsonBtn');
        learnBtn.disabled = true;
        learnBtn.textContent = '학습 중...';
        
        try {
          // JSON을 문자열로 변환하여 임베딩
          const jsonText = JSON.stringify(jsonResult, null, 2);
          const embedding = await embed_query(jsonText);
          
          if (!embedding) {
            throw new Error('임베딩 생성 실패');
          }
          
          // 인덱스에 삽입
          const response = await fetch(`${OPENSEARCH_API_BASE}/index`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              index: DEFAULT_INDEX,
              document: {
                text: jsonText,
                embedding: embedding,
                file_name: fileName,
                analysis_date: jsonResult.analysis_date || new Date().toISOString().split('T')[0]
              }
            })
          });
          
          const result = await response.json();
          console.log('[learnJsonBtn] 학습 결과:', result);
          
          if (result.result === 'created') {
            alert('학습이 완료되었습니다!\\nDocument ID: ' + result.id);
            popup.remove();
          } else {
            throw new Error('학습 실패');
          }
          
        } catch (error) {
          console.error('[learnJsonBtn] 학습 중 오류:', error);
          alert('학습 실패: ' + error.message);
          learnBtn.disabled = false;
          learnBtn.textContent = '학습 하기';
        }
      });
    }

    // 1. 인덱스 생성 (contest_pm_task)
    document.addEventListener('DOMContentLoaded', function() {
      const btn1 = document.getElementById('btn_learn_1');
      if (btn1) {
        btn1.addEventListener('click', async function() {
          console.log('[btn_learn_1] 인덱스 생성 버튼 클릭');
          
          const indexName = DEFAULT_INDEX;
          
          if (!confirm(`인덱스 "${indexName}"를 생성하시겠습니까?`)) {
            console.log('[btn_learn_1] 인덱스 생성 취소됨');
            return;
          }
          
          console.log('[btn_learn_1] 인덱스 생성 요청:', indexName);
          
          try {
            const response = await fetch(`${OPENSEARCH_API_BASE}/index_create`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ 
                index: indexName, 
                body: {} 
              })
            });
            
            const result = await response.json();
            console.log('[btn_learn_1] 인덱스 생성 응답:', result);
            
            alert(result.message || '인덱스 생성 완료: ' + indexName);
          } catch (error) {
            console.error('[btn_learn_1] 인덱스 생성 실패:', error);
            alert('인덱스 생성 실패: ' + error.message);
          }
        });
      }
      
      // 2. AI 로그 분석 후 학습
      const btn2 = document.getElementById('btn_learn_2');
      if (btn2) {
        btn2.addEventListener('click', async function() {
          console.log('[btn_learn_2] AI 로그 분석 버튼 클릭');
          
          // 파일 업로드 input 생성
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.txt,.log';
          
          fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            console.log('[btn_learn_2] 파일 선택됨:', file.name, '크기:', file.size, 'bytes');
            
            // 분석 모드 선택
            const fileSizeMB = file.size / (1024 * 1024);
            let useChunkAnalysis = false;
            
            if (fileSizeMB > 9) {
              const choice = confirm(
                `파일 크기: ${fileSizeMB.toFixed(2)} MB\n\n` +
                `전체 파일 분석 모드를 사용하시겠습니까?\n\n` +
                `[확인] 전체 분석 (${Math.ceil(fileSizeMB / 9)}개 청크, 약 ${Math.ceil(fileSizeMB / 9 * 0.3)}분 소요)\n` +
                `[취소] 샘플링 분석 (빠름, 약 1분 소요)`
              );
              useChunkAnalysis = choice;
            }
            
            try {
              const analysisDate = new Date().toISOString().split('T')[0];
              
              if (useChunkAnalysis) {
                // ========== 청크 기반 전체 분석 ==========
                console.log('[btn_learn_2] 청크 기반 전체 분석 시작');
                
                // 진행률 팝업 생성
                const progressPopup = createProgressPopup(file.name, fileSizeMB);
                document.body.appendChild(progressPopup);
                
                const CHUNK_SIZE = 9 * 1024 * 1024; // 9MB (API 제한 10MB 미만)
                const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
                console.log('[btn_learn_2] 총 청크 수:', totalChunks);
                
                let isPaused = false;
                let isCancelled = false;
                const chunkStats = [];
                
                // 일시정지 버튼
                document.getElementById('pauseAnalysisBtn').addEventListener('click', () => {
                  isPaused = !isPaused;
                  const btn = document.getElementById('pauseAnalysisBtn');
                  btn.textContent = isPaused ? '▶ 재개' : '⏸ 일시정지';
                  console.log('[btn_learn_2] 분석', isPaused ? '일시정지' : '재개');
                });
                
                // 취소 버튼
                document.getElementById('cancelAnalysisBtn').addEventListener('click', () => {
                  if (confirm('정말 분석을 취소하시겠습니까?')) {
                    isCancelled = true;
                    console.log('[btn_learn_2] 분석 취소됨');
                  }
                });
                
                // 각 청크 분석
                for (let i = 0; i < totalChunks; i++) {
                  // 일시정지 대기
                  while (isPaused && !isCancelled) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                  }
                  
                  // 취소 확인
                  if (isCancelled) {
                    progressPopup.remove();
                    alert('분석이 취소되었습니다.');
                    return;
                  }
                  
                  const start = i * CHUNK_SIZE;
                  const end = Math.min(start + CHUNK_SIZE, file.size);
                  const chunk = file.slice(start, end);
                  
                  console.log(`[btn_learn_2] 청크 ${i+1}/${totalChunks} 읽기 시작 (${start}-${end})`);
                  
                  // 진행률 업데이트
                  updateProgressPopup(i + 1, totalChunks, '청크 읽는 중...');
                  
                  const chunkText = await chunk.text();
                  
                  // 진행 상황 로그 추가
                  const detailsDiv = document.getElementById('progressDetails');
                  if (detailsDiv) {
                    const time = new Date().toLocaleTimeString();
                    detailsDiv.innerHTML += `[${time}] 청크 ${i+1}/${totalChunks} 읽기 완료 (${(chunkText.length / 1024).toFixed(1)} KB)<br>`;
                    detailsDiv.scrollTop = detailsDiv.scrollHeight;
                  }
                  
                  // 청크별 통계 추출 프롬프트 (API 제한을 고려한 크기)
                  // 프롬프트 자체 + 로그 데이터가 9MB 이하여야 함
                  const maxLogSize = 8 * 1024 * 1024; // 8MB (프롬프트 텍스트 여유 공간 확보)
                  const safeChunkText = chunkText.length > maxLogSize ? chunkText.substring(0, maxLogSize) : chunkText;
                  
                  const chunkPrompt = `다음 로그 데이터에서 통계를 추출하세요. 반드시 JSON 형식으로만 답변하세요.

로그 데이터:
${safeChunkText}

추출할 통계 (JSON 형식):
{
  "chunk_number": ${i+1},
  "total_requests": 0,
  "bizrequest_services": {},
  "hourly_usage": {},
  "users": {},
  "devices": {},
  "locations": {},
  "errors": []
}

설명:
- total_requests: _BIZREQUEST가 포함된 라인 수
- bizrequest_services: {서비스명: 횟수} 형태
- hourly_usage: {시간대: 횟수} 형태 (00~23시)
- users: {사용자명: 횟수} 형태 (PUM_USER_NAME)
- devices: {기기모델: 횟수} 형태 (DEV_MODEL)
- locations: {지역코드: 횟수} 형태 (PNM_LOCATION_CD)
- errors: [에러메시지들] 형태 (ERROR, Exception 포함)

JSON만 답변하세요.`;
                  
                  updateProgressPopup(i + 1, totalChunks, `청크 ${i+1} 분석 중...`);
                  
                  try {
                    // 진행 로그
                    if (detailsDiv) {
                      const time = new Date().toLocaleTimeString();
                      detailsDiv.innerHTML += `[${time}] 청크 ${i+1} AI 분석 요청 중...<br>`;
                      detailsDiv.scrollTop = detailsDiv.scrollHeight;
                    }
                    
                    const chunkResponse = await call_llm_api(chunkPrompt, 'qwen', true); // silentMode = true (에러 알림 무시)
                    
                    if (chunkResponse) {
                      // JSON 파싱
                      let chunkStat;
                      try {
                        const jsonMatch = chunkResponse.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                          chunkStat = JSON.parse(jsonMatch[0]);
                        } else {
                          chunkStat = JSON.parse(chunkResponse);
                        }
                        chunkStats.push(chunkStat);
                        console.log(`[btn_learn_2] 청크 ${i+1} 분석 완료:`, chunkStat);
                        
                        // 성공 로그
                        if (detailsDiv) {
                          const time = new Date().toLocaleTimeString();
                          detailsDiv.innerHTML += `[${time}] ✅ 청크 ${i+1} 분석 완료 (총 ${chunkStats.length}개 완료)<br>`;
                          detailsDiv.scrollTop = detailsDiv.scrollHeight;
                        }
                      } catch (parseError) {
                        console.error(`[btn_learn_2] 청크 ${i+1} JSON 파싱 실패:`, parseError);
                        chunkStats.push({ chunk_number: i+1, error: 'JSON 파싱 실패', raw: chunkResponse.substring(0, 500) });
                        
                        // 파싱 실패 로그
                        if (detailsDiv) {
                          const time = new Date().toLocaleTimeString();
                          detailsDiv.innerHTML += `[${time}] ⚠️ 청크 ${i+1} JSON 파싱 실패, 원본 저장<br>`;
                          detailsDiv.scrollTop = detailsDiv.scrollHeight;
                        }
                      }
                    } else {
                      // 응답이 null인 경우 (500 에러, fetch 실패 등)
                      console.warn(`[btn_learn_2] 청크 ${i+1} 응답 없음, 건너뜀`);
                      chunkStats.push({ chunk_number: i+1, error: 'API 호출 실패 (무시됨)', skipped: true });
                      
                      // 건너뛰기 로그
                      if (detailsDiv) {
                        const time = new Date().toLocaleTimeString();
                        detailsDiv.innerHTML += `[${time}] ⏭️ 청크 ${i+1} 건너뜀 (API 오류, 계속 진행)<br>`;
                        detailsDiv.scrollTop = detailsDiv.scrollHeight;
                      }
                    }
                  } catch (error) {
                    // try-catch로 잡힌 예외도 무시하고 계속 진행
                    console.warn(`[btn_learn_2] 청크 ${i+1} 예외 발생, 무시하고 계속:`, error);
                    chunkStats.push({ chunk_number: i+1, error: error.message, skipped: true });
                    
                    // 건너뛰기 로그 (경고 수준)
                    if (detailsDiv) {
                      const time = new Date().toLocaleTimeString();
                      detailsDiv.innerHTML += `[${time}] ⏭️ 청크 ${i+1} 건너뜀 (${error.message})<br>`;
                      detailsDiv.scrollTop = detailsDiv.scrollHeight;
                    }
                  }
                  
                  updateProgressPopup(i + 1, totalChunks, `청크 ${i+1}/${totalChunks} 완료`);
                }
                
                // 최종 종합 분석
                console.log('[btn_learn_2] 모든 청크 분석 완료, 최종 종합 시작');
                updateProgressPopup(totalChunks, totalChunks, '최종 종합 분석 중...');
                
                // 최종 분석 시작 로그
                const detailsDiv = document.getElementById('progressDetails');
                if (detailsDiv) {
                  const time = new Date().toLocaleTimeString();
                  detailsDiv.innerHTML += `<br>[${time}] 📊 모든 청크 분석 완료! (${chunkStats.length}/${totalChunks})<br>`;
                  detailsDiv.innerHTML += `[${time}] 🔄 최종 종합 분석 시작 (약 1~2분 소요)...<br>`;
                  detailsDiv.scrollTop = detailsDiv.scrollHeight;
                }
                
                const finalPrompt = `다음은 ${totalChunks}개 청크의 통계 데이터입니다. 이를 종합하여 최종 분석 리포트를 JSON 형식으로 작성하세요.

청크 통계:
${JSON.stringify(chunkStats, null, 2).substring(0, 8000000)}

최종 분석 JSON 형식:
{
  "analysis_date": "${analysisDate}",
  "log_file": "${file.name}",
  "total_file_size_mb": ${fileSizeMB.toFixed(2)},
  "total_chunks_analyzed": ${totalChunks},
  "analysis_request": {
    "로그 분석 인사이트": {
      "사용자 행동 패턴 분석": {
        "주요 사용 서비스": "모든 청크의 bizrequest_services를 합산하여 상위 5개 서비스와 요청 건수",
        "시간대별 사용량": "모든 청크의 hourly_usage를 합산하여 시간대별 분포",
        "사용자별 서비스 이용 현황": "모든 청크의 users를 합산하여 상위 3명",
        "기기 정보": "모든 청크의 devices를 합산하여 상위 3개 기기"
      },
      "서비스 사용 현황 분석": {
        "총 요청 건수": "모든 청크의 total_requests 합계",
        "위치 기반 서비스 분석": "모든 청크의 locations를 합산하여 상위 3개 지역",
        "일일 통계": "전체 요청 수와 주요 서비스 요약"
      },
      "시스템 성능 및 오류 분석": {
        "오류 발생 현황": "모든 청크의 errors를 종합하여 오류 종류와 빈도"
      }
    }
  }
}

반드시 JSON 형식으로만 답변하세요.`;
                
                const finalResponse = await call_llm_api(finalPrompt, 'qwen');
                
                if (!finalResponse) {
                  progressPopup.remove();
                  throw new Error('최종 종합 분석 실패');
                }
                
                console.log('[btn_learn_2] 최종 LLM 응답:', finalResponse);
                
                // 최종 분석 완료 로그
                if (detailsDiv) {
                  const time = new Date().toLocaleTimeString();
                  detailsDiv.innerHTML += `[${time}] ✅ 최종 종합 분석 완료!<br>`;
                  detailsDiv.innerHTML += `[${time}] 📝 결과 파싱 중...<br>`;
                  detailsDiv.scrollTop = detailsDiv.scrollHeight;
                }
                
                // 잠시 대기 후 팝업 닫기
                await new Promise(resolve => setTimeout(resolve, 1000));
                progressPopup.remove();
                
                // JSON 파싱
                let jsonResult;
                try {
                  const jsonMatch = finalResponse.match(/\{[\s\S]*\}/);
                  if (jsonMatch) {
                    jsonResult = JSON.parse(jsonMatch[0]);
                  } else {
                    jsonResult = JSON.parse(finalResponse);
                  }
                } catch (parseError) {
                  console.error('[btn_learn_2] 최종 JSON 파싱 실패:', parseError);
                  jsonResult = {
                    analysis_date: analysisDate,
                    log_file: file.name,
                    raw_response: finalResponse,
                    chunk_stats: chunkStats
                  };
                }
                
                // 결과 팝업 표시
                createJsonResultPopup(jsonResult, file.name);
                
              } else {
                // ========== 기존 샘플링 분석 ==========
                console.log('[btn_learn_2] 샘플링 분석 시작');
                
                const SAMPLE_SIZE = 100 * 1024; // 100KB
                let logSample = '';
                
                if (file.size > SAMPLE_SIZE) {
                  const blob = file.slice(0, SAMPLE_SIZE);
                  logSample = await blob.text();
                  console.log('[btn_learn_2] 샘플 크기:', logSample.length, 'bytes');
                } else {
                  logSample = await file.text();
                  console.log('[btn_learn_2] 전체 파일 읽기 완료:', logSample.length, 'bytes');
                }
                
                const logForAnalysis = logSample.substring(0, 50000);
                
                const prompt = `로그 데이터를 자세히 분석한 후 다음 JSON 형식으로 답변해주세요.

로그 데이터 (샘플):
${logForAnalysis}

요청하는 JSON 형식:
{
  "analysis_date": "${analysisDate}",
  "log_file": "${file.name}",
  "analysis_request": {
    "로그 분석 인사이트": {
      "사용자 행동 패턴 분석": {
        "주요 사용 서비스": "로그에서 '_BIZREQUEST' 필드를 분석하여 가장 많이 사용된 서비스 상위 5개를 식별하고, 각 서비스의 요청 건수를 포함하여 결과를 제시해줘.",
        "시간대별 사용량": "로그 생성 시간을 기준으로 시간대별(00시, 01시, ..., 23시) 서비스 요청 건수를 분석하고, 사용량이 가장 많은 시간대와 가장 적은 시간대를 알려줘.",
        "사용자별 서비스 이용 현황": "'PUM_USER_NAME' 필드를 기준으로 가장 요청이 많았던 사용자 상위 3명을 식별하고, 각 사용자의 총 요청 건수를 알려줘.",
        "기기 정보": "'DEV_MODEL'과 'DEV_TELECOM' 필드를 분석하여 가장 많이 사용된 기기 모델 상위 3개와 통신사별 점유율을 분석해줘."
      },
      "서비스 사용 현황 분석": {
        "요청 건수 및 종류": "로그 파일 전체의 총 요청 건수를 계산하고, 서비스 종류별 요청 건수와 비율을 분석해줘.",
        "위치 기반 서비스 분석": "'PNM_LOCATION_CD' 필드를 기준으로 지역 코드별 요청 건수를 분석하고, 가장 요청이 많았던 상위 3개 지역을 알려줘.",
        "월별/일별 통계": "이 로그는 '${analysisDate}'에 해당하는 일일 통계임을 명시하고, 주요 통계(총 요청 수, 상위 서비스)를 요약해줘."
      },
      "시스템 성능 및 오류 분석": {
        "응답 시간": "로그의 타임스탬프를 분석하여 평균 응답 시간을 추정하고, 응답 시간이 유독 길었던(예: 5초 이상) 요청이 있었는지 식별해줘.",
        "오류 발생 현황": "로그 내용에서 'ERROR' 또는 'Exception' 키워드를 포함한 로그를 찾아내고, 발생한 오류의 종류와 빈도를 요약해줘."
      }
    }
  }
}

반드시 JSON 형식으로만 답변해주세요.`;

              console.log('[btn_learn_2] LLM API 호출 시작...');
              alert('AI가 로그를 분석 중입니다...\n시간이 다소 걸릴 수 있습니다.');
              
              // LLM API 호출
              const llmResponse = await call_llm_api(prompt, 'qwen');
              
              if (!llmResponse) {
                throw new Error('LLM 응답을 받지 못했습니다.');
              }
              
              console.log('[btn_learn_2] LLM 응답:', llmResponse);
              
              // JSON 파싱 시도
              let jsonResult;
              try {
                // JSON 부분만 추출 (``` 제거)
                let jsonText = llmResponse;
                const jsonMatch = llmResponse.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                  jsonText = jsonMatch[0];
                }
                jsonResult = JSON.parse(jsonText);
              } catch (parseError) {
                console.error('[btn_learn_2] JSON 파싱 실패:', parseError);
                // 파싱 실패 시 원본 응답을 JSON으로 감싸기
                jsonResult = {
                  analysis_date: analysisDate,
                  log_file: file.name,
                  raw_response: llmResponse
                };
              }
              
              // JSON 결과 팝업 표시
              createJsonResultPopup(jsonResult, file.name);
              }
              
            } catch (error) {
              console.error('[btn_learn_2] AI 분석 중 오류:', error);
              alert('AI 분석 실패: ' + error.message);
            }
          });
          
          fileInput.click();
        });
      }
      
      // 3. 로그 데이터 삽입
      const btn3 = document.getElementById('btn_learn_3');
      if (btn3) {
        btn3.addEventListener('click', async function() {
          console.log('[btn_learn_3] 데이터 삽입 버튼 클릭');
          
          if (!mainModel.logfile) {
            alert('먼저 로그 파일을 업로드하세요!');
            console.log('[btn_learn_3] 로그 파일 없음');
            return;
          }
          
          const indexName = prompt('데이터를 삽입할 인덱스 이름을 입력하세요:', 'contest_pm_task');
          if (!indexName) {
            console.log('[btn_learn_3] 데이터 삽입 취소됨');
            return;
          }
          
          console.log('[btn_learn_3] 로그 파일 읽기 시작:', mainModel.logfile.name);
          
          try {
            // 로그 파일 읽기
            const logText = await mainModel.logfile.text();
            console.log('[btn_learn_3] 로그 파일 크기:', logText.length, 'bytes');
            
            // 청크 크기 설정 (1000자 단위로 분할)
            const CHUNK_SIZE = 1000;
            const chunks = [];
            
            for (let i = 0; i < logText.length; i += CHUNK_SIZE) {
              chunks.push(logText.substring(i, i + CHUNK_SIZE));
            }
            
            console.log('[btn_learn_3] 총 청크 수:', chunks.length);
            
            if (!confirm(`총 ${chunks.length}개의 청크로 분할됩니다.\n계속하시겠습니까?`)) {
              console.log('[btn_learn_3] 사용자 취소');
              return;
            }
            
            // 각 청크를 인덱스에 삽입
            let successCount = 0;
            let failCount = 0;
            
            for (let i = 0; i < chunks.length; i++) {
              const chunk = chunks[i];
              console.log(`[btn_learn_3] 청크 ${i+1}/${chunks.length} 처리 중...`);
              
              // 임베딩 생성
              const embedding = await embed_query(chunk);
              
              if (!embedding) {
                console.error(`[btn_learn_3] 청크 ${i+1} 임베딩 실패`);
                failCount++;
                continue;
              }
              
              // 데이터 삽입
              const response = await fetch(`${OPENSEARCH_API_BASE}/index`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  index: indexName,
                  document: {
                    text: chunk,
                    embedding: embedding
                  }
                })
              });
              
              const result = await response.json();
              console.log(`[btn_learn_3] 청크 ${i+1} 삽입 결과:`, result);
              
              if (result.result === 'created') {
                successCount++;
              } else {
                failCount++;
              }
              
              // 진행률 표시 (10개마다)
              if ((i + 1) % 10 === 0) {
                console.log(`[btn_learn_3] 진행률: ${i+1}/${chunks.length}`);
              }
            }
            
            console.log('[btn_learn_3] 데이터 삽입 완료');
            console.log('[btn_learn_3] 성공:', successCount, '실패:', failCount);
            alert(`데이터 삽입 완료!\n성공: ${successCount}개\n실패: ${failCount}개`);
            
          } catch (error) {
            console.error('[btn_learn_3] 데이터 삽입 중 오류:', error);
            alert('데이터 삽입 실패: ' + error.message);
          }
        });
      }
      
      // 4. 학습 데이터 검색 (KNN + 키워드)
      const btn4 = document.getElementById('btn_learn_4');
      if (btn4) {
        btn4.addEventListener('click', async function() {
          console.log('[btn_learn_4] 학습 데이터 검색 버튼 클릭');
          
          // 검색 타입 선택 팝업
          const searchPopup = document.createElement('div');
          searchPopup.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
          `;
          
          searchPopup.innerHTML = `
            <div style="
              background: #0a0e27;
              border: 2px solid #00ffff;
              border-radius: 10px;
              padding: 30px;
              min-width: 500px;
              box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
            ">
              <h2 style="color: #00ffff; margin-top: 0; text-align: center;">
                ◆ 학습 데이터 검색 ◆
              </h2>
              
              <div style="margin: 20px 0;">
                <label style="color: #0f0; display: block; margin-bottom: 10px;">검색 타입:</label>
                <select id="searchType" style="
                  width: 100%;
                  padding: 10px;
                  background: #000;
                  color: #0f0;
                  border: 1px solid #00ffff;
                  border-radius: 5px;
                  font-size: 14px;
                ">
                  <option value="knn">KNN 유사도 검색</option>
                  <option value="keyword">키워드 검색</option>
                </select>
              </div>
              
              <div style="margin: 20px 0;">
                <label style="color: #0f0; display: block; margin-bottom: 10px;">검색어:</label>
                <input type="text" id="searchQuery" placeholder="검색할 내용을 입력하세요" style="
                  width: 100%;
                  padding: 10px;
                  background: #000;
                  color: #0f0;
                  border: 1px solid #00ffff;
                  border-radius: 5px;
                  font-size: 14px;
                  box-sizing: border-box;
                ">
              </div>
              
              <div style="margin: 20px 0;">
                <label style="color: #0f0; display: block; margin-bottom: 10px;">결과 개수 (k):</label>
                <input type="number" id="searchK" value="3" min="1" max="10" style="
                  width: 100%;
                  padding: 10px;
                  background: #000;
                  color: #0f0;
                  border: 1px solid #00ffff;
                  border-radius: 5px;
                  font-size: 14px;
                  box-sizing: border-box;
                ">
              </div>
              
              <div id="searchResults" style="
                margin: 20px 0;
                padding: 15px;
                background: #000;
                color: #0f0;
                border: 1px solid #00ffff;
                border-radius: 5px;
                max-height: 300px;
                overflow: auto;
                display: none;
              "></div>
              
              <div style="display: flex; justify-content: center; gap: 20px; margin-top: 30px;">
                <button id="executeSearchBtn" style="
                  padding: 12px 30px;
                  background: linear-gradient(90deg, #00ff00, #00cc00);
                  color: #000;
                  border: none;
                  border-radius: 8px;
                  font-size: 16px;
                  font-weight: bold;
                  cursor: pointer;
                  box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
                ">검색 실행</button>
                <button id="askLlmBtn" style="
                  padding: 12px 30px;
                  background: linear-gradient(90deg, #ffaa00, #ff8800);
                  color: #000;
                  border: none;
                  border-radius: 8px;
                  font-size: 16px;
                  font-weight: bold;
                  cursor: pointer;
                  box-shadow: 0 0 20px rgba(255, 170, 0, 0.5);
                  display: none;
                ">LLM에게 질문</button>
                <button id="closeSearchBtn" style="
                  padding: 12px 30px;
                  background: linear-gradient(90deg, #ff6b6b, #ff0000);
                  color: #fff;
                  border: none;
                  border-radius: 8px;
                  font-size: 16px;
                  font-weight: bold;
                  cursor: pointer;
                  box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
                ">닫기</button>
              </div>
            </div>
          `;
          
          document.body.appendChild(searchPopup);
          
          let searchResultsData = [];
          
          // 검색 실행 버튼
          document.getElementById('executeSearchBtn').addEventListener('click', async () => {
            const searchType = document.getElementById('searchType').value;
            const query = document.getElementById('searchQuery').value.trim();
            const k = parseInt(document.getElementById('searchK').value);
            
            if (!query) {
              alert('검색어를 입력하세요!');
              return;
            }
            
            console.log('[btn_learn_4] 검색 실행:', searchType, query, k);
            
            try {
              const apiUrl = searchType === 'knn' 
                ? `${OPENSEARCH_API_BASE}/knn_search`
                : `${OPENSEARCH_API_BASE}/keyword_search`;
              
              const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  text: query,
                  index: DEFAULT_INDEX,
                  k: k
                })
              });
              
              const data = await response.json();
              searchResultsData = data.result || [];
              
              console.log('[btn_learn_4] 검색 결과:', searchResultsData);
              
              // 결과 표시
              const resultsDiv = document.getElementById('searchResults');
              resultsDiv.style.display = 'block';
              
              if (searchResultsData.length === 0) {
                resultsDiv.innerHTML = '<p>검색 결과가 없습니다.</p>';
                document.getElementById('askLlmBtn').style.display = 'none';
              } else {
                resultsDiv.innerHTML = searchResultsData.map((item, idx) => `
                  <div style="margin-bottom: 15px; padding: 10px; background: #001a1a; border-left: 3px solid #00ffff;">
                    <strong style="color: #00ffff;">결과 ${idx + 1}:</strong>
                    <pre style="white-space: pre-wrap; margin-top: 10px;">${item}</pre>
                  </div>
                `).join('');
                document.getElementById('askLlmBtn').style.display = 'inline-block';
              }
              
            } catch (error) {
              console.error('[btn_learn_4] 검색 실패:', error);
              alert('검색 실패: ' + error.message);
            }
          });
          
          // LLM에게 질문 버튼
          document.getElementById('askLlmBtn').addEventListener('click', async () => {
            const query = document.getElementById('searchQuery').value.trim();
            
            if (searchResultsData.length === 0) {
              alert('검색 결과가 없습니다!');
              return;
            }
            
            console.log('[btn_learn_4] LLM에게 질문 시작');
            
            // API 제한을 고려한 안전한 프롬프트 생성 (최대 8MB)
            const maxContextSize = 8 * 1024 * 1024; // 8MB
            let combinedResults = searchResultsData.join('\n\n');
            
            if (combinedResults.length > maxContextSize) {
              console.log('[btn_learn_4] 검색 결과가 너무 큼, 잘라냄:', combinedResults.length, '->', maxContextSize);
              combinedResults = combinedResults.substring(0, maxContextSize) + '\n\n... (결과가 너무 길어 일부만 표시됨)';
            }
            
            const prompt = combinedResults 
              + '\n\n위 내용을 참고하여 아래 질문에 답변하세요.\n\n질문: ' + query;
            
            try {
              const llmResponse = await call_llm_api(prompt, 'qwen');
              
              if (llmResponse) {
                alert('LLM 답변:\n\n' + llmResponse);
                console.log('[btn_learn_4] LLM 답변:', llmResponse);
              }
              
            } catch (error) {
              console.error('[btn_learn_4] LLM 질문 실패:', error);
              alert('LLM 질문 실패: ' + error.message);
            }
          });
          
          // 닫기 버튼
          document.getElementById('closeSearchBtn').addEventListener('click', () => {
            searchPopup.remove();
          });
        });
      }
      
      // 5. 인덱스 삭제
      const btn5 = document.getElementById('btn_learn_5');
      if (btn5) {
        btn5.addEventListener('click', async function() {
          console.log('[btn_learn_5] 인덱스 삭제 버튼 클릭');
          
          const indexName = prompt('삭제할 인덱스 이름을 입력하세요:', DEFAULT_INDEX);
          if (!indexName) {
            console.log('[btn_learn_5] 인덱스 삭제 취소됨');
            return;
          }
          
          if (!confirm(`정말로 인덱스 "${indexName}"를 삭제하시겠습니까?\n이 작업은 되돌릴 수 없습니다!`)) {
            console.log('[btn_learn_5] 사용자가 삭제 취소');
            return;
          }
          
          console.log('[btn_learn_5] 인덱스 삭제 요청:', indexName);
          
          try {
            const response = await fetch(`${OPENSEARCH_API_BASE}/index_delete`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ index: indexName })
            });
            
            const result = await response.json();
            console.log('[btn_learn_5] 인덱스 삭제 결과:', result);
            
            if (result.result && result.result.acknowledged) {
              alert(`인덱스 "${indexName}" 삭제 완료!`);
            } else {
              alert('인덱스 삭제 완료');
            }
            
          } catch (error) {
            console.error('[btn_learn_5] 인덱스 삭제 실패:', error);
            alert('인덱스 삭제 실패: ' + error.message);
          }
        });
      }
      
      // 6. 로컬 전처리 후 AI 요약 (빠른 분석)
      const btn6 = document.getElementById('btn_learn_6');
      if (btn6) {
        btn6.addEventListener('click', async function() {
          console.log('[btn_learn_6] 로컬 전처리 분석 버튼 클릭');
          
          // 파일 업로드 input 생성
          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.accept = '.txt,.log';
          
          fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const fileSizeMB = file.size / (1024 * 1024);
            console.log('[btn_learn_6] 파일 선택됨:', file.name, '크기:', fileSizeMB.toFixed(2), 'MB');
            
            if (!confirm(`파일: ${file.name}\n크기: ${fileSizeMB.toFixed(2)} MB\n\n로컬 전처리 분석을 시작하시겠습니까?\n(JavaScript로 직접 통계 계산 후 AI 요약)`)) {
              return;
            }
            
            try {
              // 진행률 팝업 생성
              const progressPopup = createProgressPopup(file.name, fileSizeMB);
              document.body.appendChild(progressPopup);
              
              updateProgressPopup(0, 100, '파일 읽기 시작...');
              
              // === 1단계: 로컬 통계 계산 ===
              console.log('[btn_learn_6] 1단계: 로컬 통계 계산 시작');
              
              const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB 청크로 읽기 (메모리 효율)
              const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
              
              // 통계 데이터 초기화
              const stats = {
                fileName: file.name,
                fileSizeMB: fileSizeMB.toFixed(2),
                totalLines: 0,
                totalRequests: 0,
                bizrequestServices: {},
                hourlyUsage: {},
                users: {},
                devices: {},
                locations: {},
                errors: [],
                dateRange: { start: null, end: null }
              };
              
              let buffer = ''; // 청크 경계 처리용 버퍼
              
              // 각 청크를 순차적으로 읽으면서 통계 계산
              for (let i = 0; i < totalChunks; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                const chunk = file.slice(start, end);
                
                updateProgressPopup(
                  Math.floor((i / totalChunks) * 50), 
                  100, 
                  `통계 계산 중... (${i+1}/${totalChunks} 청크)`
                );
                
                const chunkText = await chunk.text();
                const fullText = buffer + chunkText;
                
                // 마지막 줄이 불완전할 수 있으므로 버퍼에 저장
                const lastNewlineIndex = fullText.lastIndexOf('\n');
                const processText = lastNewlineIndex !== -1 ? fullText.substring(0, lastNewlineIndex) : fullText;
                buffer = lastNewlineIndex !== -1 ? fullText.substring(lastNewlineIndex + 1) : '';
                
                // 줄 단위로 통계 계산
                const lines = processText.split('\n');
                stats.totalLines += lines.length;
                
                for (const line of lines) {
                  if (!line.trim()) continue;
                  
                  // BIZREQUEST 카운트
                  if (line.includes('_BIZREQUEST')) {
                    stats.totalRequests++;
                    
                    // 서비스명 추출 (예: pm.service.XXX)
                    const serviceMatch = line.match(/pm\.service\.(\w+)/);
                    if (serviceMatch) {
                      const serviceName = serviceMatch[1];
                      stats.bizrequestServices[serviceName] = (stats.bizrequestServices[serviceName] || 0) + 1;
                    }
                  }
                  
                  // 시간대 추출 (예: 2024-01-15 14:23:45)
                  const timeMatch = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}):/);
                  if (timeMatch) {
                    const date = timeMatch[1];
                    const hour = timeMatch[2];
                    
                    // 날짜 범위 업데이트
                    if (!stats.dateRange.start || date < stats.dateRange.start) {
                      stats.dateRange.start = date;
                    }
                    if (!stats.dateRange.end || date > stats.dateRange.end) {
                      stats.dateRange.end = date;
                    }
                    
                    // 시간대별 사용량
                    stats.hourlyUsage[hour] = (stats.hourlyUsage[hour] || 0) + 1;
                  }
                  
                  // 사용자명 추출 (PUM_USER_NAME)
                  const userMatch = line.match(/PUM_USER_NAME[=:]\s*([^\s,\]]+)/);
                  if (userMatch) {
                    const userName = userMatch[1];
                    stats.users[userName] = (stats.users[userName] || 0) + 1;
                  }
                  
                  // 기기 모델 추출 (DEV_MODEL)
                  const deviceMatch = line.match(/DEV_MODEL[=:]\s*([^\s,\]]+)/);
                  if (deviceMatch) {
                    const deviceModel = deviceMatch[1];
                    stats.devices[deviceModel] = (stats.devices[deviceModel] || 0) + 1;
                  }
                  
                  // 지역 코드 추출 (PNM_LOCATION_CD)
                  const locationMatch = line.match(/PNM_LOCATION_CD[=:]\s*([^\s,\]]+)/);
                  if (locationMatch) {
                    const locationCode = locationMatch[1];
                    stats.locations[locationCode] = (stats.locations[locationCode] || 0) + 1;
                  }
                  
                  // 에러 추출 (ERROR, Exception 포함)
                  if (line.match(/ERROR|Exception|exception|FAIL|fail/i)) {
                    // 에러 메시지 추출 (너무 길면 자르기)
                    const errorMsg = line.trim().substring(0, 200);
                    if (stats.errors.length < 50) { // 최대 50개까지만 저장
                      stats.errors.push(errorMsg);
                    }
                  }
                }
                
                // 진행 로그
                const detailsDiv = document.getElementById('progressDetails');
                if (detailsDiv) {
                  const time = new Date().toLocaleTimeString();
                  detailsDiv.innerHTML += `[${time}] 청크 ${i+1}/${totalChunks} 처리 완료 (누적 라인: ${stats.totalLines.toLocaleString()})<br>`;
                  detailsDiv.scrollTop = detailsDiv.scrollHeight;
                }
              }
              
              // 마지막 버퍼 처리
              if (buffer.trim()) {
                stats.totalLines++;
              }
              
              console.log('[btn_learn_6] 로컬 통계 계산 완료:', stats);
              updateProgressPopup(50, 100, '로컬 통계 계산 완료! AI 요약 요청 중...');
              
              // 진행 로그
              const detailsDiv = document.getElementById('progressDetails');
              if (detailsDiv) {
                const time = new Date().toLocaleTimeString();
                detailsDiv.innerHTML += `<br>[${time}] ✅ 로컬 통계 계산 완료!<br>`;
                detailsDiv.innerHTML += `[${time}] 📊 총 ${stats.totalLines.toLocaleString()} 라인 분석<br>`;
                detailsDiv.innerHTML += `[${time}] 🔄 AI 요약 생성 시작...<br>`;
                detailsDiv.scrollTop = detailsDiv.scrollHeight;
              }
              
              // === 2단계: AI 요약 생성 ===
              console.log('[btn_learn_6] 2단계: AI 요약 생성 시작');
              
              // 상위 N개만 추출
              const topN = (obj, n) => {
                return Object.entries(obj)
                  .sort((a, b) => b[1] - a[1])
                  .slice(0, n)
                  .reduce((acc, [key, val]) => ({ ...acc, [key]: val }), {});
              };
              
              // 요약용 통계 데이터
              const summaryStats = {
                fileName: stats.fileName,
                fileSizeMB: stats.fileSizeMB,
                totalLines: stats.totalLines,
                totalRequests: stats.totalRequests,
                dateRange: stats.dateRange,
                topServices: topN(stats.bizrequestServices, 10),
                hourlyUsage: stats.hourlyUsage,
                topUsers: topN(stats.users, 10),
                topDevices: topN(stats.devices, 10),
                topLocations: topN(stats.locations, 10),
                errorSamples: stats.errors.slice(0, 20) // 대표 에러 20개
              };
              
              // AI 요약 프롬프트
              const summaryPrompt = `다음은 로그 파일의 통계 분석 결과입니다. 이를 기반으로 인사이트 있는 분석 리포트를 JSON 형식으로 작성하세요.

통계 데이터:
${JSON.stringify(summaryStats, null, 2)}

아래 형식으로 JSON 응답을 작성하세요:
{
  "analysis_summary": {
    "overview": "로그 파일 전체 요약 (파일명, 기간, 총 라인 수, 총 요청 수)",
    "key_insights": [
      "주요 인사이트 1",
      "주요 인사이트 2",
      "주요 인사이트 3"
    ]
  },
  "service_analysis": {
    "most_used_services": "가장 많이 사용된 서비스 상위 5개와 사용량",
    "service_distribution": "서비스 사용 분포에 대한 설명"
  },
  "temporal_analysis": {
    "peak_hours": "최고 사용 시간대 (상위 3개 시간)",
    "usage_pattern": "시간대별 사용 패턴 설명",
    "date_range": "분석 기간"
  },
  "user_analysis": {
    "active_users": "가장 활발한 사용자 상위 3명과 사용량",
    "user_distribution": "사용자 분포 특징"
  },
  "device_analysis": {
    "popular_devices": "주요 기기 모델 상위 3개",
    "device_insight": "기기 사용 패턴"
  },
  "location_analysis": {
    "main_locations": "주요 지역 상위 3개",
    "location_insight": "지역별 사용 특징"
  },
  "error_analysis": {
    "error_count": "에러 샘플 수",
    "error_patterns": "주요 에러 패턴 및 유형",
    "recommendations": "권장 조치사항"
  },
  "recommendations": [
    "개선 제안 1",
    "개선 제안 2",
    "개선 제안 3"
  ]
}

반드시 JSON 형식으로만 답변하세요. 추가 설명은 불필요합니다.`;
              
              updateProgressPopup(60, 100, 'AI 요약 생성 중...');
              
              const aiResponse = await call_llm_api(summaryPrompt, 'qwen');
              
              if (!aiResponse) {
                throw new Error('AI 요약 생성 실패');
              }
              
              console.log('[btn_learn_6] AI 요약 완료');
              updateProgressPopup(100, 100, '분석 완료!');
              
              if (detailsDiv) {
                const time = new Date().toLocaleTimeString();
                detailsDiv.innerHTML += `[${time}] ✅ AI 요약 생성 완료!<br>`;
                detailsDiv.scrollTop = detailsDiv.scrollHeight;
              }
              
              // === 3단계: 결과 표시 ===
              setTimeout(() => {
                progressPopup.remove();
                
                // JSON 파싱
                let analysisResult;
                try {
                  const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
                  if (jsonMatch) {
                    analysisResult = JSON.parse(jsonMatch[0]);
                  } else {
                    analysisResult = JSON.parse(aiResponse);
                  }
                } catch (parseError) {
                  console.error('[btn_learn_6] JSON 파싱 실패:', parseError);
                  analysisResult = { raw_response: aiResponse };
                }
                
                // 결과 팝업 생성 (btn_learn_2와 동일한 형식)
                const combinedResult = {
                  local_statistics: summaryStats,
                  ai_analysis: analysisResult,
                  processing_info: {
                    method: 'Local preprocessing + AI summary',
                    total_chunks_processed: totalChunks,
                    processing_time: '약 2~5분',
                    file_size_mb: fileSizeMB.toFixed(2)
                  }
                };
                
                createJsonResultPopup(combinedResult, file.name);
                
                console.log('[btn_learn_6] 전체 분석 완료!');
                
              }, 1000);
              
            } catch (error) {
              console.error('[btn_learn_6] 분석 실패:', error);
              alert('분석 실패: ' + error.message);
              
              const popup = document.getElementById('progressPopup');
              if (popup) popup.remove();
            }
          });
          
          fileInput.click();
        });
      }
    });
  </script>
</body>
</html>
