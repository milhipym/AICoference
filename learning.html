<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>로그 학습 시스템</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #e0e0e0;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      text-align: center;
      margin-bottom: 40px;
      padding: 30px;
      background: rgba(0, 255, 255, 0.05);
      border-radius: 15px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.2);
      position: relative;
    }

    .header h1 {
      font-size: 36px;
      color: #00ffff;
      text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      margin-bottom: 10px;
      letter-spacing: 3px;
    }

    .header p {
      font-size: 16px;
      color: #00d9ff;
    }

    .back-button {
      position: absolute;
      left: 30px;
      top: 50%;
      transform: translateY(-50%);
      padding: 10px 20px;
      background: linear-gradient(135deg, #00d9ff, #00ffff);
      color: #0a0e27;
      border: none;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
      text-decoration: none;
      display: inline-block;
    }

    .back-button:hover {
      transform: translateY(-50%) scale(1.05);
      box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
    }

    .learning-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 25px;
      margin-bottom: 30px;
    }

    .learning-card {
      background: linear-gradient(135deg, rgba(0, 255, 255, 0.08), rgba(0, 217, 255, 0.05));
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 15px;
      padding: 30px;
      transition: all 0.3s;
      position: relative;
      overflow: hidden;
    }

    .learning-card::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        45deg,
        transparent,
        rgba(0, 255, 255, 0.1),
        transparent
      );
      transform: rotate(45deg);
      transition: all 0.5s;
    }

    .learning-card:hover::before {
      left: 100%;
    }

    .learning-card:hover {
      transform: translateY(-5px);
      border-color: rgba(0, 255, 255, 0.6);
      box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(0, 255, 255, 0.2);
    }

    .card-number {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #00d9ff, #00ffff);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      color: #0a0e27;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .card-title {
      flex: 1;
    }

    .card-title h3 {
      font-size: 22px;
      color: #00ffff;
      margin-bottom: 5px;
      text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .card-title p {
      font-size: 13px;
      color: #00d9ff;
      opacity: 0.8;
    }

    .card-body {
      margin-bottom: 20px;
    }

    .card-description {
      color: #b0b0b0;
      line-height: 1.6;
      font-size: 14px;
      margin-bottom: 15px;
    }

    .card-features {
      list-style: none;
      padding: 0;
    }

    .card-features li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
      color: #d0d0d0;
      font-size: 13px;
    }

    .card-features li::before {
      content: '▸';
      position: absolute;
      left: 0;
      color: #00ffff;
      font-size: 16px;
    }

    .execute-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #00d9ff, #00ffff);
      color: #0a0e27;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 5px 20px rgba(0, 255, 255, 0.3);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .execute-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 30px rgba(0, 255, 255, 0.5);
    }

    .execute-button:active {
      transform: translateY(0);
    }

    .execute-button:disabled {
      background: rgba(100, 100, 100, 0.5);
      cursor: not-allowed;
      box-shadow: none;
    }

    .status-indicator {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
      background: #666;
      animation: pulse 2s ease-in-out infinite;
    }

    .status-indicator.ready {
      background: #00ffff;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    }

    .status-indicator.processing {
      background: #ffaa00;
      box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
    }

    .status-indicator.success {
      background: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }

    .status-indicator.error {
      background: #ff6b6b;
      box-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .result-panel {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(0, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      margin-top: 15px;
      max-height: 200px;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #00ff88;
      display: none;
    }

    .result-panel.show {
      display: block;
    }

    .result-panel::-webkit-scrollbar {
      width: 8px;
    }

    .result-panel::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }

    .result-panel::-webkit-scrollbar-thumb {
      background: rgba(0, 255, 255, 0.3);
      border-radius: 4px;
    }

    .result-panel::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 255, 255, 0.5);
    }

    .info-panel {
      background: rgba(0, 217, 255, 0.1);
      border: 2px solid rgba(0, 217, 255, 0.3);
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 30px;
    }

    .info-panel h4 {
      color: #00ffff;
      margin-bottom: 15px;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .info-panel ul {
      list-style: none;
      padding: 0;
    }

    .info-panel li {
      padding: 8px 0;
      padding-left: 25px;
      position: relative;
      color: #d0d0d0;
      line-height: 1.6;
    }

    .info-panel li::before {
      content: '✓';
      position: absolute;
      left: 0;
      color: #00ff88;
      font-weight: bold;
    }

    @media (max-width: 768px) {
      .learning-grid {
        grid-template-columns: 1fr;
      }

      .back-button {
        position: static;
        transform: none;
        margin-bottom: 20px;
      }

      .header h1 {
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <a href="index.html" class="back-button">← 돌아가기</a>
      <h1>◈ LOG LEARNING SYSTEM ◈</h1>
      <p>OpenSearch AI 학습 관리 시스템</p>
    </div>

    <div class="info-panel">
      <h4>
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="10"></circle>
          <line x1="12" y1="16" x2="12" y2="12"></line>
          <line x1="12" y1="8" x2="12.01" y2="8"></line>
        </svg>
        사용 가이드
      </h4>
      <ul>
        <li>먼저 메인 화면에서 로그 파일을 업로드한 후 이 페이지로 이동하세요</li>
        <li>학습 순서: <strong>1 → 6 → (필요시 2, 3)</strong> 순서로 실행하는 것을 권장합니다</li>
        <li>각 기능은 독립적으로 실행 가능하지만, 인덱스가 먼저 생성되어야 합니다</li>
        <li>학습이 완료된 후 '종합 분석' 페이지에서 월간 추세 분석을 확인할 수 있습니다</li>
      </ul>
    </div>

    <div class="learning-grid">
      <!-- btn_learn_1: 인덱스 생성 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">1</div>
          <div class="card-title">
            <h3>인덱스 생성</h3>
            <p>OpenSearch Index Initialize</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            OpenSearch에 새로운 인덱스를 생성합니다. 
            모든 학습 작업의 기반이 되는 저장소를 만듭니다.
          </p>
          <ul class="card-features">
            <li>인덱스명: contest_pm_task</li>
            <li>벡터 임베딩 필드 설정</li>
            <li>메타데이터 스키마 정의</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn1()">
          <span class="status-indicator ready"></span>
          인덱스 생성 실행
        </button>
        <div id="result1" class="result-panel"></div>
      </div>

      <!-- btn_learn_2: AI 답변 학습 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">2</div>
          <div class="card-title">
            <h3>AI 답변 학습</h3>
            <p>AI Response Learning</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            업로드된 로그 파일을 AI에게 먼저 분석시킨 후, 
            AI의 답변을 포함하여 학습합니다.
          </p>
          <ul class="card-features">
            <li>vLLM API로 로그 분석 요청</li>
            <li>AI 분석 결과를 메타데이터로 저장</li>
            <li>임베딩과 함께 인덱스에 삽입</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn2()">
          <span class="status-indicator ready"></span>
          AI 답변 학습 실행
        </button>
        <div id="result2" class="result-panel"></div>
      </div>

      <!-- btn_learn_3: 임베딩 학습 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">3</div>
          <div class="card-title">
            <h3>임베딩 학습</h3>
            <p>Text Embedding Learning</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            업로드된 로그 파일을 청크 단위로 나누어 
            임베딩 벡터를 생성하고 저장합니다.
          </p>
          <ul class="card-features">
            <li>로그 텍스트를 청크로 분할</li>
            <li>/embed API로 벡터 생성</li>
            <li>OpenSearch에 벡터 저장</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn3()">
          <span class="status-indicator ready"></span>
          임베딩 학습 실행
        </button>
        <div id="result3" class="result-panel"></div>
      </div>

      <!-- btn_learn_4: 학습 데이터 호출 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">4</div>
          <div class="card-title">
            <h3>학습 데이터 호출</h3>
            <p>Retrieve Learning Data</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            OpenSearch에 저장된 학습 데이터를 조회하고 
            검증합니다.
          </p>
          <ul class="card-features">
            <li>인덱스에 저장된 문서 수 확인</li>
            <li>최근 학습 데이터 미리보기</li>
            <li>날짜별 데이터 분포 확인</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn4()">
          <span class="status-indicator ready"></span>
          데이터 호출 실행
        </button>
        <div id="result4" class="result-panel"></div>
      </div>

      <!-- btn_learn_5: 인덱스 삭제 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">5</div>
          <div class="card-title">
            <h3>인덱스 삭제</h3>
            <p>Delete Index</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            OpenSearch 인덱스를 완전히 삭제합니다. 
            <strong style="color: #ff6b6b;">주의: 모든 데이터가 삭제됩니다!</strong>
          </p>
          <ul class="card-features">
            <li>인덱스 및 모든 데이터 삭제</li>
            <li>재학습 전 초기화 용도</li>
            <li>복구 불가능 - 신중히 사용</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn5()" style="background: linear-gradient(135deg, #ff6b6b, #ff4444);">
          <span class="status-indicator ready"></span>
          인덱스 삭제 실행
        </button>
        <div id="result5" class="result-panel"></div>
      </div>

      <!-- btn_learn_6: 자체 분석 후 학습 -->
      <div class="learning-card">
        <div class="card-header">
          <div class="card-number">6</div>
          <div class="card-title">
            <h3>자체 분석 후 학습</h3>
            <p>Local Analysis & Learning</p>
          </div>
        </div>
        <div class="card-body">
          <p class="card-description">
            로그 파일을 로컬에서 직접 분석한 후 
            결과를 OpenSearch에 저장합니다. (권장)
          </p>
          <ul class="card-features">
            <li>2-5분 내 빠른 분석 (AI 호출 없음)</li>
            <li>요청 수, 에러, 시간대 등 통계 수집</li>
            <li>월간 추세 분석용 데이터 생성</li>
          </ul>
        </div>
        <button class="execute-button" onclick="executeLearn6()">
          <span class="status-indicator ready"></span>
          자체 분석 학습 실행
        </button>
        <div id="result6" class="result-panel"></div>
      </div>
    </div>
  </div>

  <script>
    // ==================== 공통 설정 ====================
    const OPENSEARCH_API_BASE = "http://10.10.22.81:8080";
    const DEFAULT_INDEX = "contest_pm_task";
    
    // 공통 결과 표시 함수
    function showResult(taskNumber, message, isSuccess = true) {
      const resultPanel = document.getElementById(`result${taskNumber}`);
      const button = document.querySelector(`#result${taskNumber}`).previousElementSibling;
      const indicator = button.querySelector('.status-indicator');
      
      resultPanel.classList.add('show');
      resultPanel.textContent += `[${new Date().toLocaleTimeString()}] ${message}\n`;
      
      if (isSuccess) {
        indicator.className = 'status-indicator success';
      } else {
        indicator.className = 'status-indicator error';
      }
      
      setTimeout(() => {
        indicator.className = 'status-indicator ready';
        button.disabled = false;
      }, 2000);
    }
    
    // 상태 업데이트 함수
    function updateStatus(taskNumber, status) {
      const button = document.querySelector(`#result${taskNumber}`).previousElementSibling;
      const indicator = button.querySelector('.status-indicator');
      const resultPanel = document.getElementById(`result${taskNumber}`);
      
      if (status === 'processing') {
        indicator.className = 'status-indicator processing';
        button.disabled = true;
        resultPanel.classList.add('show');
        resultPanel.textContent = `[${new Date().toLocaleTimeString()}] 실행 중...\n`;
      } else if (status === 'ready') {
        indicator.className = 'status-indicator ready';
        button.disabled = false;
      }
    }
    
    // 임베딩 생성 함수
    async function embed_query(text) {
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/embed`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: text })
        });
        const data = await response.json();
        return data.embedding || null;
      } catch (error) {
        console.error('임베딩 생성 실패:', error);
        return null;
      }
    }
    
    // LLM API 호출 함수
    async function call_llm_api(prompt, model, silentMode = false, customLimit = null) {
      const limit = customLimit !== null ? customLimit : 4096;
      console.log('[call_llm_api] LLM 호출 시작, model:', model, 'silentMode:', silentMode, 'limit:', limit);
      
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/vllm_chat`, {
          method: 'POST',
          headers: { 
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ 
            text: prompt, 
            model: model,
            limit: limit
          })
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('[call_llm_api] LLM 응답 받음, 길이:', data.content?.length);
        return data.content;
      } catch (error) {
        console.error('[call_llm_api] LLM 호출 실패:', error);
        
        // silentMode가 false일 때만 alert 표시
        if (!silentMode) {
          alert('AI 분석 중 오류 발생: ' + error.message);
        }
        return null;
      }
    }
    
    // 진행률 팝업 생성
    function createProgressPopup(fileName, fileSizeMB) {
      const popup = document.createElement('div');
      popup.id = 'progressPopup';
      popup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
      `;
      
      popup.innerHTML = `
        <div style="
          background: #0a0e27;
          border: 2px solid #00ffff;
          border-radius: 10px;
          padding: 40px;
          min-width: 600px;
          box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        ">
          <h2 style="color: #00ffff; margin-top: 0; text-align: center;">
            ◆ 파일 처리 중 ◆
          </h2>
          <p style="color: #888; text-align: center; margin-bottom: 30px;">
            파일: ${fileName} (${fileSizeMB.toFixed(2)} MB)
          </p>
          
          <div style="margin: 20px 0;">
            <div style="
              background: #000;
              border: 1px solid #00ffff;
              border-radius: 10px;
              height: 30px;
              overflow: hidden;
              position: relative;
            ">
              <div id="progressBar" style="
                background: linear-gradient(90deg, #00ff00, #00ffff);
                height: 100%;
                width: 0%;
                transition: width 0.3s;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
              "></div>
              <div id="progressText" style="
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                color: #fff;
                font-weight: bold;
                text-shadow: 0 0 5px #000;
              ">0%</div>
            </div>
          </div>
          
          <p id="progressStatus" style="
            color: #0f0;
            text-align: center;
            margin: 20px 0;
            min-height: 20px;
          ">준비 중...</p>
          
          <div id="progressDetails" style="
            background: #000;
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 15px;
            color: #0f0;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin: 20px 0;
          "></div>
          
          <div style="display: flex; justify-content: center; gap: 20px; margin-top: 30px;">
            <button id="closeProgressBtn" style="
              padding: 12px 30px;
              background: linear-gradient(90deg, #00ff00, #00cc00);
              color: #000;
              border: none;
              border-radius: 8px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
              display: none;
            ">✓ 닫기</button>
          </div>
        </div>
      `;
      
      return popup;
    }
    
    // 진행률 업데이트
    function updateProgressPopup(current, total, status) {
      const percentage = Math.floor((current / total) * 100);
      const progressBar = document.getElementById('progressBar');
      const progressText = document.getElementById('progressText');
      const progressStatus = document.getElementById('progressStatus');
      const progressDetails = document.getElementById('progressDetails');
      
      if (progressBar) progressBar.style.width = percentage + '%';
      if (progressText) progressText.textContent = percentage + '%';
      if (progressStatus) progressStatus.textContent = status;
      
      // 상세 로그 추가
      if (progressDetails) {
        const now = new Date().toLocaleTimeString();
        progressDetails.innerHTML += `[${now}] ${status}<br>`;
        progressDetails.scrollTop = progressDetails.scrollHeight;
      }
      
      // 완료시 닫기 버튼 표시
      if (percentage >= 100) {
        const closeBtn = document.getElementById('closeProgressBtn');
        if (closeBtn) {
          closeBtn.style.display = 'block';
          closeBtn.onclick = () => {
            const popup = document.getElementById('progressPopup');
            if (popup) popup.remove();
          };
        }
      }
    }

    // ==================== 학습 기능 1: 인덱스 생성 ====================
    async function executeLearn1() {
      console.log('[btn_learn_1] 인덱스 생성 시작');
      updateStatus(1, 'processing');
      
      const indexName = DEFAULT_INDEX;
      
      if (!confirm(`인덱스 "${indexName}"를 생성하시겠습니까?`)) {
        console.log('[btn_learn_1] 취소됨');
        updateStatus(1, 'ready');
        return;
      }
      
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/index_create`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            index: indexName, 
            body: {} 
          })
        });
        
        const result = await response.json();
        console.log('[btn_learn_1] 결과:', result);
        
        showResult(1, `✓ 인덱스 생성 완료: ${indexName}\n${JSON.stringify(result, null, 2)}`, true);
        alert(result.message || '인덱스 생성 완료: ' + indexName);
        
      } catch (error) {
        console.error('[btn_learn_1] 실패:', error);
        showResult(1, `✗ 인덱스 생성 실패: ${error.message}`, false);
        alert('인덱스 생성 실패: ' + error.message);
      }
    }

    // ==================== 학습 기능 2: AI 답변 학습 ====================
    async function executeLearn2() {
      console.log('[btn_learn_2] AI 로그 분석 버튼 클릭');
      
      // 파일 업로드 input 생성
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.txt,.log';
      
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        console.log('[btn_learn_2] 파일 선택됨:', file.name, '크기:', file.size, 'bytes');
        
        // 분석 모드 선택
        const fileSizeMB = file.size / (1024 * 1024);
        let useChunkAnalysis = false;
        
        if (fileSizeMB > 9) {
          const choice = confirm(
            `파일 크기: ${fileSizeMB.toFixed(2)} MB\n\n` +
            `전체 파일 분석 모드를 사용하시겠습니까?\n\n` +
            `[확인] 전체 분석 (${Math.ceil(fileSizeMB / 9)}개 청크, 약 ${Math.ceil(fileSizeMB / 9 * 0.3)}분 소요)\n` +
            `[취소] 샘플링 분석 (빠름, 약 1분 소요)`
          );
          useChunkAnalysis = choice;
        }
        
        try {
          const analysisDate = new Date().toISOString().split('T')[0];
          
          if (useChunkAnalysis) {
            // ========== 청크 기반 전체 분석 ==========
            console.log('[btn_learn_2] 청크 기반 전체 분석 시작');
            
            // 진행률 팝업 생성
            const progressPopup = createProgressPopup(file.name, fileSizeMB);
            document.body.appendChild(progressPopup);
            
            const CHUNK_SIZE = 9 * 1024 * 1024; // 9MB (API 제한 10MB 미만)
            const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
            console.log('[btn_learn_2] 총 청크 수:', totalChunks);
            
            let isPaused = false;
            let isCancelled = false;
            const chunkStats = [];
            
            // 일시정지 버튼
            document.getElementById('pauseAnalysisBtn').addEventListener('click', () => {
              isPaused = !isPaused;
              const btn = document.getElementById('pauseAnalysisBtn');
              btn.textContent = isPaused ? '▶ 재개' : '⏸ 일시정지';
              console.log('[btn_learn_2] 분석', isPaused ? '일시정지' : '재개');
            });
            
            // 취소 버튼
            document.getElementById('cancelAnalysisBtn').addEventListener('click', () => {
              if (confirm('정말 분석을 취소하시겠습니까?')) {
                isCancelled = true;
                console.log('[btn_learn_2] 분석 취소됨');
              }
            });
            
            // 각 청크 분석
            for (let i = 0; i < totalChunks; i++) {
              // 일시정지 대기
              while (isPaused && !isCancelled) {
                await new Promise(resolve => setTimeout(resolve, 500));
              }
              
              // 취소 확인
              if (isCancelled) {
                progressPopup.remove();
                alert('분석이 취소되었습니다.');
                return;
              }
              
              const start = i * CHUNK_SIZE;
              const end = Math.min(start + CHUNK_SIZE, file.size);
              const chunk = file.slice(start, end);
              
              console.log(`[btn_learn_2] 청크 ${i+1}/${totalChunks} 읽기 시작 (${start}-${end})`);
              
              // 진행률 업데이트
              updateProgressPopup(i + 1, totalChunks, '청크 읽는 중...');
              
              const chunkText = await chunk.text();
              
              // 진행 상황 로그 추가
              const detailsDiv = document.getElementById('progressDetails');
              if (detailsDiv) {
                const time = new Date().toLocaleTimeString();
                detailsDiv.innerHTML += `[${time}] 청크 ${i+1}/${totalChunks} 읽기 완료 (${(chunkText.length / 1024).toFixed(1)} KB)<br>`;
                detailsDiv.scrollTop = detailsDiv.scrollHeight;
              }
              
              // 청크별 통계 추출 프롬프트 (API 제한을 고려한 크기)
              // 프롬프트 자체 + 로그 데이터가 9MB 이하여야 함
              const maxLogSize = 8 * 1024 * 1024; // 8MB (프롬프트 텍스트 여유 공간 확보)
              const safeChunkText = chunkText.length > maxLogSize ? chunkText.substring(0, maxLogSize) : chunkText;
              
              const chunkPrompt = `다음 로그 데이터에서 통계를 추출하세요. 반드시 JSON 형식으로만 답변하세요.

로그 데이터:
${safeChunkText}

추출할 통계 (JSON 형식):
{
  "chunk_number": ${i+1},
  "total_requests": 0,
  "bizrequest_services": {},
  "hourly_usage": {},
  "users": {},
  "devices": {},
  "locations": {},
  "errors": []
}

설명:
- total_requests: _BIZREQUEST가 포함된 라인 수
- bizrequest_services: {서비스명: 횟수} 형태
- hourly_usage: {시간대: 횟수} 형태 (00~23시)
- users: {사용자명: 횟수} 형태 (PUM_USER_NAME)
- devices: {기기모델: 횟수} 형태 (DEV_MODEL)
- locations: {지역코드: 횟수} 형태 (PNM_LOCATION_CD)
- errors: [에러메시지들] 형태 (ERROR, Exception 포함)

JSON만 답변하세요.`;
              
              updateProgressPopup(i + 1, totalChunks, `청크 ${i+1} 분석 중...`);
              
              try {
                // 진행 로그
                if (detailsDiv) {
                  const time = new Date().toLocaleTimeString();
                  detailsDiv.innerHTML += `[${time}] 청크 ${i+1} AI 분석 요청 중...<br>`;
                  detailsDiv.scrollTop = detailsDiv.scrollHeight;
                }
                
                const chunkResponse = await call_llm_api(chunkPrompt, 'qwen', true); // silentMode = true (에러 알림 무시)
                
                if (chunkResponse) {
                  // JSON 파싱
                  let chunkStat;
                  try {
                    const jsonMatch = chunkResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                      chunkStat = JSON.parse(jsonMatch[0]);
                    } else {
                      chunkStat = JSON.parse(chunkResponse);
                    }
                    chunkStats.push(chunkStat);
                    console.log(`[btn_learn_2] 청크 ${i+1} 분석 완료:`, chunkStat);
                    
                    // 성공 로그
                    if (detailsDiv) {
                      const time = new Date().toLocaleTimeString();
                      detailsDiv.innerHTML += `[${time}] ✅ 청크 ${i+1} 분석 완료 (총 ${chunkStats.length}개 완료)<br>`;
                      detailsDiv.scrollTop = detailsDiv.scrollHeight;
                    }
                  } catch (parseError) {
                    console.error(`[btn_learn_2] 청크 ${i+1} JSON 파싱 실패:`, parseError);
                    chunkStats.push({ chunk_number: i+1, error: 'JSON 파싱 실패', raw: chunkResponse.substring(0, 500) });
                    
                    // 파싱 실패 로그
                    if (detailsDiv) {
                      const time = new Date().toLocaleTimeString();
                      detailsDiv.innerHTML += `[${time}] ⚠️ 청크 ${i+1} JSON 파싱 실패, 원본 저장<br>`;
                      detailsDiv.scrollTop = detailsDiv.scrollHeight;
                    }
                  }
                } else {
                  // 응답이 null인 경우 (500 에러, fetch 실패 등)
                  console.warn(`[btn_learn_2] 청크 ${i+1} 응답 없음, 건너뜀`);
                  chunkStats.push({ chunk_number: i+1, error: 'API 호출 실패 (무시됨)', skipped: true });
                  
                  // 건너뛰기 로그
                  if (detailsDiv) {
                    const time = new Date().toLocaleTimeString();
                    detailsDiv.innerHTML += `[${time}] ⏭️ 청크 ${i+1} 건너뜀 (API 오류, 계속 진행)<br>`;
                    detailsDiv.scrollTop = detailsDiv.scrollHeight;
                  }
                }
              } catch (error) {
                // try-catch로 잡힌 예외도 무시하고 계속 진행
                console.warn(`[btn_learn_2] 청크 ${i+1} 예외 발생, 무시하고 계속:`, error);
                chunkStats.push({ chunk_number: i+1, error: error.message, skipped: true });
                
                // 건너뛰기 로그 (경고 수준)
                if (detailsDiv) {
                  const time = new Date().toLocaleTimeString();
                  detailsDiv.innerHTML += `[${time}] ⏭️ 청크 ${i+1} 건너뜀 (${error.message})<br>`;
                  detailsDiv.scrollTop = detailsDiv.scrollHeight;
                }
              }
              
              updateProgressPopup(i + 1, totalChunks, `청크 ${i+1}/${totalChunks} 완료`);
            }
            
            // 최종 종합 분석
            console.log('[btn_learn_2] 모든 청크 분석 완료, 최종 종합 시작');
            updateProgressPopup(totalChunks, totalChunks, '최종 종합 분석 중...');
            
            // 최종 분석 시작 로그
            const detailsDiv = document.getElementById('progressDetails');
            if (detailsDiv) {
              const time = new Date().toLocaleTimeString();
              detailsDiv.innerHTML += `<br>[${time}] 📊 모든 청크 분석 완료! (${chunkStats.length}/${totalChunks})<br>`;
              detailsDiv.innerHTML += `[${time}] 🔄 최종 종합 분석 시작 (약 1~2분 소요)...<br>`;
              detailsDiv.scrollTop = detailsDiv.scrollHeight;
            }
            
            const finalPrompt = `다음은 ${totalChunks}개 청크의 통계 데이터입니다. 이를 종합하여 최종 분석 리포트를 JSON 형식으로 작성하세요.

청크 통계:
${JSON.stringify(chunkStats, null, 2).substring(0, 8000000)}

최종 분석 JSON 형식:
{
  "analysis_date": "${analysisDate}",
  "log_file": "${file.name}",
  "total_file_size_mb": ${fileSizeMB.toFixed(2)},
  "total_chunks_analyzed": ${totalChunks},
  "analysis_request": {
    "로그 분석 인사이트": {
      "사용자 행동 패턴 분석": {
        "주요 사용 서비스": "모든 청크의 bizrequest_services를 합산하여 상위 5개 서비스와 요청 건수",
        "시간대별 사용량": "모든 청크의 hourly_usage를 합산하여 시간대별 분포",
        "사용자별 서비스 이용 현황": "모든 청크의 users를 합산하여 상위 3명",
        "기기 정보": "모든 청크의 devices를 합산하여 상위 3개 기기"
      },
      "서비스 사용 현황 분석": {
        "총 요청 건수": "모든 청크의 total_requests 합계",
        "위치 기반 서비스 분석": "모든 청크의 locations를 합산하여 상위 3개 지역",
        "일일 통계": "전체 요청 수와 주요 서비스 요약"
      },
      "시스템 성능 및 오류 분석": {
        "오류 발생 현황": "모든 청크의 errors를 종합하여 오류 종류와 빈도"
      }
    }
  }
}

반드시 JSON 형식으로만 답변하세요.`;
            
            // 더 긴 응답을 받기 위해 limit 증가 (4096 -> 16384)
            const finalResponse = await call_llm_api(finalPrompt, 'qwen', false, 16384);
            
            if (!finalResponse) {
              progressPopup.remove();
              throw new Error('최종 종합 분석 실패');
            }
            
            console.log('[btn_learn_2] 최종 LLM 응답:', finalResponse);
            
            // 최종 분석 완료 로그
            if (detailsDiv) {
              const time = new Date().toLocaleTimeString();
              detailsDiv.innerHTML += `[${time}] ✅ 최종 종합 분석 완료!<br>`;
              detailsDiv.innerHTML += `[${time}] 📝 결과 파싱 중...<br>`;
              detailsDiv.scrollTop = detailsDiv.scrollHeight;
            }
            
            // 잠시 대기 후 팝업 닫기
            await new Promise(resolve => setTimeout(resolve, 1000));
            progressPopup.remove();
            
            // JSON 파싱
            let jsonResult;
            try {
              const jsonMatch = finalResponse.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                jsonResult = JSON.parse(jsonMatch[0]);
              } else {
                jsonResult = JSON.parse(finalResponse);
              }
            } catch (parseError) {
              console.error('[btn_learn_2] 최종 JSON 파싱 실패:', parseError);
              jsonResult = {
                analysis_date: analysisDate,
                log_file: file.name,
                raw_response: finalResponse,
                chunk_stats: chunkStats
              };
            }
            
            // 결과 팝업 표시
            createJsonResultPopup(jsonResult, file.name);
            
          } else {
            // ========== 기존 샘플링 분석 ==========
            console.log('[btn_learn_2] 샘플링 분석 시작');
            
            const SAMPLE_SIZE = 100 * 1024; // 100KB
            let logSample = '';
            
            if (file.size > SAMPLE_SIZE) {
              const blob = file.slice(0, SAMPLE_SIZE);
              logSample = await blob.text();
              console.log('[btn_learn_2] 샘플 크기:', logSample.length, 'bytes');
            } else {
              logSample = await file.text();
              console.log('[btn_learn_2] 전체 파일 읽기 완료:', logSample.length, 'bytes');
            }
            
            const logForAnalysis = logSample.substring(0, 50000);
            
            const prompt = `로그 데이터를 자세히 분석한 후 다음 JSON 형식으로 답변해주세요.

로그 데이터 (샘플):
${logForAnalysis}

요청하는 JSON 형식:
{
  "analysis_date": "${analysisDate}",
  "log_file": "${file.name}",
  "analysis_request": {
    "로그 분석 인사이트": {
      "사용자 행동 패턴 분석": {
        "주요 사용 서비스": "로그에서 '_BIZREQUEST' 필드를 분석하여 가장 많이 사용된 서비스 상위 5개를 식별하고, 각 서비스의 요청 건수를 포함하여 결과를 제시해줘.",
        "시간대별 사용량": "로그 생성 시간을 기준으로 시간대별(00시, 01시, ..., 23시) 서비스 요청 건수를 분석하고, 사용량이 가장 많은 시간대와 가장 적은 시간대를 알려줘.",
        "사용자별 서비스 이용 현황": "'PUM_USER_NAME' 필드를 기준으로 가장 요청이 많았던 사용자 상위 3명을 식별하고, 각 사용자의 총 요청 건수를 알려줘.",
        "기기 정보": "'DEV_MODEL'과 'DEV_TELECOM' 필드를 분석하여 가장 많이 사용된 기기 모델 상위 3개와 통신사별 점유율을 분석해줘."
      },
      "서비스 사용 현황 분석": {
        "요청 건수 및 종류": "로그 파일 전체의 총 요청 건수를 계산하고, 서비스 종류별 요청 건수와 비율을 분석해줘.",
        "위치 기반 서비스 분석": "'PNM_LOCATION_CD' 필드를 기준으로 지역 코드별 요청 건수를 분석하고, 가장 요청이 많았던 상위 3개 지역을 알려줘.",
        "월별/일별 통계": "이 로그는 '${analysisDate}'에 해당하는 일일 통계임을 명시하고, 주요 통계(총 요청 수, 상위 서비스)를 요약해줘."
      },
      "시스템 성능 및 오류 분석": {
        "응답 시간": "로그의 타임스탬프를 분석하여 평균 응답 시간을 추정하고, 응답 시간이 유독 길었던(예: 5초 이상) 요청이 있었는지 식별해줘.",
        "오류 발생 현황": "로그 내용에서 'ERROR' 또는 'Exception' 키워드를 포함한 로그를 찾아내고, 발생한 오류의 종류와 빈도를 요약해줘."
      }
    }
  }
}

반드시 JSON 형식으로만 답변해주세요.`;

          console.log('[btn_learn_2] LLM API 호출 시작...');
          alert('AI가 로그를 분석 중입니다...\n시간이 다소 걸릴 수 있습니다.');
          
          // LLM API 호출
          const llmResponse = await call_llm_api(prompt, 'qwen');
          
          if (!llmResponse) {
            throw new Error('LLM 응답을 받지 못했습니다.');
          }
          
          console.log('[btn_learn_2] LLM 응답:', llmResponse);
          
          // JSON 파싱 시도
          let jsonResult;
          try {
            // JSON 부분만 추출 (``` 제거)
            let jsonText = llmResponse;
            const jsonMatch = llmResponse.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              jsonText = jsonMatch[0];
            }
            jsonResult = JSON.parse(jsonText);
          } catch (parseError) {
            console.error('[btn_learn_2] JSON 파싱 실패:', parseError);
            // 파싱 실패 시 원본 응답을 JSON으로 감싸기
            jsonResult = {
              analysis_date: analysisDate,
              log_file: file.name,
              raw_response: llmResponse
            };
          }
          
          // JSON 결과 팝업 표시
          createJsonResultPopup(jsonResult, file.name);
          }
          
        } catch (error) {
          console.error('[btn_learn_2] AI 분석 중 오류:', error);
          alert('AI 분석 실패: ' + error.message);
        }
      });
      
      fileInput.click();
    }

    // ==================== 학습 기능 3: 임베딩 학습 ====================
    async function executeLearn3() {
      console.log('[btn_learn_3] 데이터 삽입 버튼 클릭');
      
      // 파일 업로드 input 생성
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.txt,.log';
      
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const indexName = prompt('데이터를 삽입할 인덱스 이름을 입력하세요:', 'contest_pm_task');
        if (!indexName) {
          console.log('[btn_learn_3] 데이터 삽입 취소됨');
          return;
        }
        
        console.log('[btn_learn_3] 로그 파일 읽기 시작:', file.name);
        
        try {
          // 로그 파일 읽기
          const logText = await file.text();
          console.log('[btn_learn_3] 로그 파일 크기:', logText.length, 'bytes');
          
          // 청크 크기 설정 (1000자 단위로 분할)
          const CHUNK_SIZE = 1000;
          const chunks = [];
          
          for (let i = 0; i < logText.length; i += CHUNK_SIZE) {
            chunks.push(logText.substring(i, i + CHUNK_SIZE));
          }
          
          console.log('[btn_learn_3] 총 청크 수:', chunks.length);
          
          if (!confirm(`총 ${chunks.length}개의 청크로 분할됩니다.\n계속하시겠습니까?`)) {
            console.log('[btn_learn_3] 사용자 취소');
            return;
          }
          
          // 각 청크를 인덱스에 삽입
          let successCount = 0;
          let failCount = 0;
          
          for (let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            console.log(`[btn_learn_3] 청크 ${i+1}/${chunks.length} 처리 중...`);
            
            // 임베딩 생성
            const embedding = await embed_query(chunk);
            
            if (!embedding) {
              console.error(`[btn_learn_3] 청크 ${i+1} 임베딩 실패`);
              failCount++;
              continue;
            }
            
            // 데이터 삽입
            const response = await fetch(`${OPENSEARCH_API_BASE}/index`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                index: indexName,
                document: {
                  text: chunk,
                  embedding: embedding
                }
              })
            });
            
            const result = await response.json();
            console.log(`[btn_learn_3] 청크 ${i+1} 삽입 결과:`, result);
            
            if (result.result === 'created') {
              successCount++;
            } else {
              failCount++;
            }
            
            // 진행률 표시 (10개마다)
            if ((i + 1) % 10 === 0) {
              console.log(`[btn_learn_3] 진행률: ${i+1}/${chunks.length}`);
            }
          }
          
          console.log('[btn_learn_3] 데이터 삽입 완료');
          console.log('[btn_learn_3] 성공:', successCount, '실패:', failCount);
          alert(`데이터 삽입 완료!\n성공: ${successCount}개\n실패: ${failCount}개`);
          
        } catch (error) {
          console.error('[btn_learn_3] 데이터 삽입 중 오류:', error);
          alert('데이터 삽입 실패: ' + error.message);
        }
      });
      
      fileInput.click();
    }

    // ==================== 학습 기능 4: 학습 데이터 호출 ====================
    async function executeLearn4() {
      console.log('[btn_learn_4] 학습 데이터 호출 시작');
      updateStatus(4, 'processing');
      
      const query = prompt('검색할 키워드를 입력하세요:', '');
      if (!query) {
        updateStatus(4, 'ready');
        return;
      }
      
      try {
        showResult(4, `키워드 검색: "${query}"`, true);
        
        // 키워드 검색
        const response = await fetch(`${OPENSEARCH_API_BASE}/keyword_search`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            text: query,
            index: DEFAULT_INDEX,
            k: 5
          })
        });
        
        const result = await response.json();
        console.log('[btn_learn_4] 결과:', result);
        
        if (result.result && result.result.length > 0) {
          showResult(4, `✓ ${result.result.length}개 문서 발견`, true);
          showResult(4, JSON.stringify(result.result, null, 2), true);
        } else {
          showResult(4, `검색 결과가 없습니다.`, true);
        }
        
      } catch (error) {
        console.error('[btn_learn_4] 실패:', error);
        showResult(4, `✗ 실패: ${error.message}`, false);
      }
    }

    // ==================== 학습 기능 5: 인덱스 삭제 ====================
    async function executeLearn5() {
      console.log('[btn_learn_5] 인덱스 삭제 시작');
      
      const indexName = prompt('삭제할 인덱스 이름을 입력하세요:', DEFAULT_INDEX);
      if (!indexName) {
        return;
      }
      
      if (!confirm(`⚠️ 정말로 인덱스 "${indexName}"를 삭제하시겠습니까?\n모든 학습 데이터가 삭제되며 복구할 수 없습니다!`)) {
        return;
      }
      
      updateStatus(5, 'processing');
      
      try {
        const response = await fetch(`${OPENSEARCH_API_BASE}/index_delete`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ index: indexName })
        });
        
        const result = await response.json();
        console.log('[btn_learn_5] 결과:', result);
        
        showResult(5, `✓ 인덱스 삭제 완료: ${indexName}`, true);
        showResult(5, JSON.stringify(result, null, 2), true);
        alert(`인덱스 "${indexName}" 삭제 완료!`);
        
      } catch (error) {
        console.error('[btn_learn_5] 실패:', error);
        showResult(5, `✗ 실패: ${error.message}`, false);
        alert('인덱스 삭제 실패: ' + error.message);
      }
    }

    // ==================== 학습 기능 6: 자체 분석 후 학습 ====================
    async function executeLearn6() {
      console.log('[btn_learn_6] 로컬 전처리 분석 버튼 클릭');
      
      // 파일 업로드 input 생성
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.txt,.log';
      
      fileInput.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const fileSizeMB = file.size / (1024 * 1024);
        console.log('[btn_learn_6] 파일 선택됨:', file.name, '크기:', fileSizeMB.toFixed(2), 'MB');
        
        if (!confirm(`파일: ${file.name}\n크기: ${fileSizeMB.toFixed(2)} MB\n\n로컬 전처리 분석을 시작하시겠습니까?\n(JavaScript로 직접 통계 계산 후 AI 요약)`)) {
          return;
        }
        
        try {
          // 진행률 팝업 생성
          const progressPopup = createProgressPopup(file.name, fileSizeMB);
          document.body.appendChild(progressPopup);
          
          updateProgressPopup(0, 100, '파일 읽기 시작...');
          
          // === 1단계: 로컬 통계 계산 ===
          console.log('[btn_learn_6] 1단계: 로컬 통계 계산 시작');
          
          const CHUNK_SIZE = 10 * 1024 * 1024; // 10MB 청크로 읽기 (메모리 효율)
          const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
          
          // 파일명에서 날짜 추출 (예: SystemOut_20251030.log -> 2025년 10월 30일)
          let logDate = null;
          let logDateFormatted = null;
          const dateMatch = file.name.match(/(\d{8})/); // YYYYMMDD 형식 찾기
          if (dateMatch) {
            const dateStr = dateMatch[1];
            const year = dateStr.substring(0, 4);
            const month = dateStr.substring(4, 6);
            const day = dateStr.substring(6, 8);
            logDate = `${year}-${month}-${day}`;
            logDateFormatted = `${year}년 ${parseInt(month)}월 ${parseInt(day)}일`;
            console.log('[btn_learn_6] 파일명에서 추출한 날짜:', logDate, logDateFormatted);
          }
          
          // 통계 데이터 초기화
          const stats = {
            fileName: file.name,
            logDate: logDate, // YYYY-MM-DD 형식
            logDateFormatted: logDateFormatted, // 한국어 형식
            fileSizeMB: fileSizeMB.toFixed(2),
            totalLines: 0,
            totalRequests: 0,
            totalErrors: 0, // 전체 에러 카운트
            bizrequestServices: {},
            hourlyUsage: {},
            users: {},
            devices: {},
            locations: {},
            errors: [], // 샘플 에러 (최대 100개)
            dateRange: { start: null, end: null }
          };
          
          let buffer = ''; // 청크 경계 처리용 버퍼
          
          // 각 청크를 순차적으로 읽으면서 통계 계산
          for (let i = 0; i < totalChunks; i++) {
            const start = i * CHUNK_SIZE;
            const end = Math.min(start + CHUNK_SIZE, file.size);
            const chunk = file.slice(start, end);
            
            updateProgressPopup(
              Math.floor((i / totalChunks) * 50), 
              100, 
              `통계 계산 중... (${i+1}/${totalChunks} 청크)`
            );
            
            const chunkText = await chunk.text();
            const fullText = buffer + chunkText;
            
            // 마지막 줄이 불완전할 수 있으므로 버퍼에 저장
            const lastNewlineIndex = fullText.lastIndexOf('\n');
            const processText = lastNewlineIndex !== -1 ? fullText.substring(0, lastNewlineIndex) : fullText;
            buffer = lastNewlineIndex !== -1 ? fullText.substring(lastNewlineIndex + 1) : '';
            
            // 줄 단위로 통계 계산
            const lines = processText.split('\n');
            stats.totalLines += lines.length;
            
            for (const line of lines) {
              if (!line.trim()) continue;
              
              // BIZREQUEST 카운트
              if (line.includes('_BIZREQUEST')) {
                stats.totalRequests++;
                
                // 서비스명 추출 (예: pm.service.XXX)
                const serviceMatch = line.match(/pm\.service\.(\w+)/);
                if (serviceMatch) {
                  const serviceName = serviceMatch[1];
                  stats.bizrequestServices[serviceName] = (stats.bizrequestServices[serviceName] || 0) + 1;
                }
              }
              
              // 시간대 추출 (예: 2024-01-15 14:23:45)
              const timeMatch = line.match(/(\d{4}-\d{2}-\d{2})\s+(\d{2}):/);
              if (timeMatch) {
                const date = timeMatch[1];
                const hour = timeMatch[2];
                
                // 날짜 범위 업데이트
                if (!stats.dateRange.start || date < stats.dateRange.start) {
                  stats.dateRange.start = date;
                }
                if (!stats.dateRange.end || date > stats.dateRange.end) {
                  stats.dateRange.end = date;
                }
                
                // 시간대별 사용량
                stats.hourlyUsage[hour] = (stats.hourlyUsage[hour] || 0) + 1;
              }
              
              // 사용자명 추출 (PUM_USER_NAME)
              const userMatch = line.match(/PUM_USER_NAME[=:]\s*([^\s,\]]+)/);
              if (userMatch) {
                const userName = userMatch[1];
                stats.users[userName] = (stats.users[userName] || 0) + 1;
              }
              
              // 기기 모델 추출 (DEV_MODEL)
              const deviceMatch = line.match(/DEV_MODEL[=:]\s*([^\s,\]]+)/);
              if (deviceMatch) {
                const deviceModel = deviceMatch[1];
                stats.devices[deviceModel] = (stats.devices[deviceModel] || 0) + 1;
              }
              
              // 지역 코드 추출 (PNM_LOCATION_CD)
              const locationMatch = line.match(/PNM_LOCATION_CD[=:]\s*([^\s,\]]+)/);
              if (locationMatch) {
                const locationCode = locationMatch[1];
                stats.locations[locationCode] = (stats.locations[locationCode] || 0) + 1;
              }
              
              // 에러 추출 (ERROR, Exception 포함)
              if (line.match(/ERROR|Exception|exception|FAIL|fail/i)) {
                stats.totalErrors++; // 전체 에러 카운트
                
                // 에러 샘플 저장 (최대 100개)
                if (stats.errors.length < 100) {
                  const errorMsg = line.trim().substring(0, 200);
                  stats.errors.push(errorMsg);
                }
              }
            }
            
            // 진행 로그
            const detailsDiv = document.getElementById('progressDetails');
            if (detailsDiv) {
              const time = new Date().toLocaleTimeString();
              detailsDiv.innerHTML += `[${time}] 청크 ${i+1}/${totalChunks} 처리 완료 (누적 라인: ${stats.totalLines.toLocaleString()})<br>`;
              detailsDiv.scrollTop = detailsDiv.scrollHeight;
            }
          }
          
          // 마지막 버퍼 처리
          if (buffer.trim()) {
            stats.totalLines++;
          }
          
          console.log('[btn_learn_6] 로컬 통계 계산 완료:', stats);
          updateProgressPopup(50, 100, '로컬 통계 계산 완료! AI 요약 요청 중...');
          
          // 진행 로그
          const detailsDiv = document.getElementById('progressDetails');
          if (detailsDiv) {
            const time = new Date().toLocaleTimeString();
            detailsDiv.innerHTML += `<br>[${time}] ✅ 로컬 통계 계산 완료!<br>`;
            detailsDiv.innerHTML += `[${time}] 📊 총 ${stats.totalLines.toLocaleString()} 라인 분석<br>`;
            detailsDiv.innerHTML += `[${time}] 🔄 AI 요약 생성 시작...<br>`;
            detailsDiv.scrollTop = detailsDiv.scrollHeight;
          }
          
          // === 2단계: AI 요약 생성 ===
          console.log('[btn_learn_6] 2단계: AI 요약 생성 시작');
          
          // 상위 N개만 추출
          const topN = (obj, n) => {
            return Object.entries(obj)
              .sort((a, b) => b[1] - a[1])
              .slice(0, n)
              .reduce((acc, [key, val]) => ({ ...acc, [key]: val }), {});
          };
          
          // 요약용 통계 데이터
          const summaryStats = {
            fileName: stats.fileName,
            logDate: stats.logDate,
            logDateFormatted: stats.logDateFormatted,
            fileSizeMB: stats.fileSizeMB,
            totalLines: stats.totalLines,
            totalRequests: stats.totalRequests,
            totalErrors: stats.totalErrors, // 전체 에러 수
            dateRange: stats.dateRange,
            topServices: topN(stats.bizrequestServices, 10),
            hourlyUsage: stats.hourlyUsage,
            topUsers: topN(stats.users, 10),
            topDevices: topN(stats.devices, 10),
            topLocations: topN(stats.locations, 10),
            errorSamples: stats.errors.slice(0, 20) // 대표 에러 20개
          };
          
          // AI 요약 프롬프트
          const summaryPrompt = `당신은 한국어 로그 분석 전문가입니다. 다음은 "${stats.logDateFormatted || '날짜 미상'}" 로그 파일의 통계 분석 결과입니다. 
이를 기반으로 인사이트 있는 분석 리포트를 **반드시 한국어**로 JSON 형식으로 작성하세요.

**중요: 모든 설명과 분석 내용은 한국어로 작성해야 합니다.**

통계 데이터:
${JSON.stringify(summaryStats, null, 2)}

아래 형식으로 JSON 응답을 작성하세요:
{
  "log_date": "${stats.logDate || '날짜 미상'}",
  "log_date_formatted": "${stats.logDateFormatted || '날짜 미상'}",
  "file_name": "${stats.fileName}",
  "analysis_summary": {
    "overview": "이 로그는 ${stats.logDateFormatted || '날짜 미상'}의 데이터입니다. 총 라인 수, 총 요청 수 등을 포함한 전체 요약을 한국어로 작성",
    "key_insights": [
      "주요 인사이트 1 (한국어)",
      "주요 인사이트 2 (한국어)",
      "주요 인사이트 3 (한국어)"
    ]
  },
  "service_analysis": {
    "most_used_services": "가장 많이 사용된 서비스 상위 5개와 사용량을 한국어로 설명",
    "service_distribution": "서비스 사용 분포에 대한 한국어 설명"
  },
  "temporal_analysis": {
    "peak_hours": "최고 사용 시간대 (예: 08시, 09시, 10시)를 한국어로 설명",
    "usage_pattern": "시간대별 사용 패턴을 한국어로 상세 설명",
    "date_range": "${stats.logDateFormatted || '날짜 미상'}의 로그 데이터"
  },
  "user_analysis": {
    "active_users": "가장 활발한 사용자 상위 3명과 사용량을 한국어로 설명",
    "user_distribution": "사용자 분포 특징을 한국어로 설명"
  },
  "device_analysis": {
    "popular_devices": "주요 기기 모델 상위 3개를 한국어로 설명",
    "device_insight": "기기 사용 패턴을 한국어로 설명"
  },
  "location_analysis": {
    "main_locations": "주요 지역 코드 상위 3개를 한국어로 설명",
    "location_insight": "지역별 사용 특징을 한국어로 설명"
  },
  "error_analysis": {
    "total_error_count": ${stats.totalErrors},
    "error_samples_count": "에러 샘플 수 (숫자)",
    "error_patterns": "주요 에러 패턴 및 유형을 한국어로 설명",
    "recommendations": "권장 조치사항을 한국어로 설명"
  },
  "recommendations": [
    "개선 제안 1 (한국어)",
    "개선 제안 2 (한국어)",
    "개선 제안 3 (한국어)"
  ],
  "searchable_info": {
    "date": "${stats.logDate}",
    "date_kr": "${stats.logDateFormatted}",
    "purpose": "이 정보는 '${stats.logDateFormatted}에는 어떤 에러가 있었어?' 같은 날짜별 검색을 위한 메타데이터입니다."
  }
}

**필수 요구사항:**
1. 모든 설명과 분석은 반드시 한국어로 작성
2. 날짜 정보(log_date, log_date_formatted)를 명확히 포함
3. 로그 내용 자체(에러 메시지 등)는 원문 유지
4. 분석과 인사이트는 한국어로 상세하게 작성
5. 이 데이터는 OpenSearch에 저장되어 날짜별 검색에 사용됩니다

반드시 JSON 형식으로만 답변하세요.`;
          
          updateProgressPopup(60, 100, 'AI 요약 생성 중...');
          
          // 더 긴 응답을 받기 위해 limit 증가 (4096 -> 16384)
          const aiResponse = await call_llm_api(summaryPrompt, 'qwen', false, 16384);
          
          if (!aiResponse) {
            throw new Error('AI 요약 생성 실패');
          }
          
          console.log('[btn_learn_6] AI 요약 완료');
          updateProgressPopup(100, 100, '분석 완료!');
          
          if (detailsDiv) {
            const time = new Date().toLocaleTimeString();
            detailsDiv.innerHTML += `[${time}] ✅ AI 요약 생성 완료!<br>`;
            detailsDiv.scrollTop = detailsDiv.scrollHeight;
          }
          
          // === 3단계: 결과 표시 ===
          setTimeout(() => {
            progressPopup.remove();
            
            // JSON 파싱
            let analysisResult;
            try {
              const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
              if (jsonMatch) {
                analysisResult = JSON.parse(jsonMatch[0]);
              } else {
                analysisResult = JSON.parse(aiResponse);
              }
            } catch (parseError) {
              console.error('[btn_learn_6] JSON 파싱 실패:', parseError);
              analysisResult = { raw_response: aiResponse };
            }
            
            // 결과 팝업 생성 (btn_learn_2와 동일한 형식)
            const combinedResult = {
              local_statistics: summaryStats,
              ai_analysis: analysisResult,
              processing_info: {
                method: 'Local preprocessing + AI summary',
                total_chunks_processed: totalChunks,
                processing_time: '약 2~5분',
                file_size_mb: fileSizeMB.toFixed(2)
              }
            };
            
            createJsonResultPopup(combinedResult, file.name);
            
            console.log('[btn_learn_6] 전체 분석 완료!');
            
          }, 1000);
          
        } catch (error) {
          console.error('[btn_learn_6] 분석 실패:', error);
          alert('분석 실패: ' + error.message);
          
          const popup = document.getElementById('progressPopup');
          if (popup) popup.remove();
        }
      });
      
      fileInput.click();
    }

    // 페이지 로드 시
    window.addEventListener('DOMContentLoaded', () => {
      console.log('로그 학습 페이지 로드 완료');
    });
  </script>
</body>
</html>
